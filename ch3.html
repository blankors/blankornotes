<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>3 Retail Sales 零售销售 | 数据仓库工具箱第三版笔记</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="The Data Warehouse Toolkit 3rd Edition">
    
    <link rel="preload" href="/blankornotes/assets/css/0.styles.372fc7a5.css" as="style"><link rel="preload" href="/blankornotes/assets/js/app.c947165e.js" as="script"><link rel="preload" href="/blankornotes/assets/js/2.a76d4e78.js" as="script"><link rel="preload" href="/blankornotes/assets/js/1.2ec8c7d7.js" as="script"><link rel="preload" href="/blankornotes/assets/js/25.0618aee1.js" as="script"><link rel="prefetch" href="/blankornotes/assets/js/10.4c178469.js"><link rel="prefetch" href="/blankornotes/assets/js/11.31060eb5.js"><link rel="prefetch" href="/blankornotes/assets/js/12.279f272d.js"><link rel="prefetch" href="/blankornotes/assets/js/13.10227dfa.js"><link rel="prefetch" href="/blankornotes/assets/js/14.fe714d02.js"><link rel="prefetch" href="/blankornotes/assets/js/15.f53ca535.js"><link rel="prefetch" href="/blankornotes/assets/js/16.d3d5bdeb.js"><link rel="prefetch" href="/blankornotes/assets/js/17.4ef2ea13.js"><link rel="prefetch" href="/blankornotes/assets/js/18.37f5f491.js"><link rel="prefetch" href="/blankornotes/assets/js/19.b774cdca.js"><link rel="prefetch" href="/blankornotes/assets/js/20.5d9c4a68.js"><link rel="prefetch" href="/blankornotes/assets/js/21.47844c93.js"><link rel="prefetch" href="/blankornotes/assets/js/22.06fabd8a.js"><link rel="prefetch" href="/blankornotes/assets/js/23.903b1507.js"><link rel="prefetch" href="/blankornotes/assets/js/24.feb64cbc.js"><link rel="prefetch" href="/blankornotes/assets/js/26.685c9a85.js"><link rel="prefetch" href="/blankornotes/assets/js/27.694ace99.js"><link rel="prefetch" href="/blankornotes/assets/js/3.fb6a4e15.js"><link rel="prefetch" href="/blankornotes/assets/js/4.e9f08a68.js"><link rel="prefetch" href="/blankornotes/assets/js/5.3ffe72e2.js"><link rel="prefetch" href="/blankornotes/assets/js/6.8910dfd2.js"><link rel="prefetch" href="/blankornotes/assets/js/7.d094995e.js"><link rel="prefetch" href="/blankornotes/assets/js/vendors~docsearch.06f5d163.js">
    <link rel="stylesheet" href="/blankornotes/assets/css/0.styles.372fc7a5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blankornotes/" class="home-link router-link-active"><!----> <span class="site-name">数据仓库工具箱第三版笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blankornotes/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="blankor的博客" class="dropdown-title"><span class="title">blankor的博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="blankor的博客" class="mobile-dropdown-title"><span class="title">blankor的博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/u012928365" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blankornotes/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="blankor的博客" class="dropdown-title"><span class="title">blankor的博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="blankor的博客" class="mobile-dropdown-title"><span class="title">blankor的博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/u012928365" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blankornotes/" aria-current="page" class="sidebar-link">阅读方式</a></li><li><a href="/blankornotes/ch1.html" class="sidebar-link">第一章</a></li><li><a href="/blankornotes/ch2.html" class="sidebar-link">第二章</a></li><li><a href="/blankornotes/ch3.html" aria-current="page" class="active sidebar-link">第三章</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#四步维度设计流程" class="sidebar-link">四步维度设计流程</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#retail-case-study-零售案例研究" class="sidebar-link">Retail Case Study 零售案例研究</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#维度表详细信息" class="sidebar-link">维度表详细信息</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#retail-schema-in-action" class="sidebar-link">Retail Schema in Action</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#retail-schema-extensibility" class="sidebar-link">Retail Schema Extensibility</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#无事实事实表" class="sidebar-link">无事实事实表</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#维度和事实表键" class="sidebar-link">维度和事实表键</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#抵制规范化冲动" class="sidebar-link">抵制规范化冲动</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch3.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/blankornotes/ch6.html" class="sidebar-link">第六章</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_3-retail-sales-零售销售"><a href="#_3-retail-sales-零售销售" class="header-anchor">#</a> 3 Retail Sales 零售销售</h1> <p>理解维度建模原理的<strong>最佳方式</strong>是通过一系列实际的示例进行学习。通过可视化真实案例，你能比抽象地学习更有效地记住特定的设计挑战和解决方案。本书使用来自不同行业的案例研究，帮助你跨越自身环境的特殊性，强化维度建模的最佳实践方法。</p> <p>即便你并不管理零售商店，也不在电信公司工作，为了学习维度建模，请阅读本书的所有章节。</p> <ul><li>这些章节并非针对特定行业或业务功能的完整解决方案，每一章都涵盖了一系列在几乎各类业务中都会出现的维度建模模式。大学、保险公司、银行和航空公司等，无疑都需要本章中阐述的零售相关技术。</li> <li>此外，思考其他企业的业务能带来新的启发。在处理自己公司的数据时，历史遗留的复杂性很容易让你偏离方向。而当你跳出自己的组织，掌握了一两个易于理解的设计原则后再回归，在深入钻研自身业务的复杂细节时，就更容易记住这些设计原则的精髓。</li></ul> <p>本章将讨论以下概念：</p> <ul><li>维度模型设计的四步流程</li> <li>事实表粒度</li> <li>事务事实表</li> <li>可加、不可加和派生事实</li> <li>维度属性，包括指标、数字描述符和多个层次结构</li> <li>日历日期维度，以及时间维度</li> <li>因果维度，如促销</li> <li>退化维度，如交易收据编号</li> <li>维度模型中的空值</li> <li>维度模型的可扩展性</li> <li>无事实事实表</li> <li>代理键、自然键和持久键</li> <li>雪花型维度属性</li> <li>维度过多的蜈蚣型事实表</li></ul> <h2 id="四步维度设计流程"><a href="#四步维度设计流程" class="header-anchor">#</a> 四步维度设计流程</h2> <p>在本书中，我们将通过始终如一地考虑四个步骤来进行维度模型的设计，以下各节将对此进行更详细的讨论。</p> <h3 id="步骤1-选择业务流程"><a href="#步骤1-选择业务流程" class="header-anchor">#</a> 步骤1：选择业务流程</h3> <p>业务流程是组织执行的底层活动，比如下订单、开具发票、接收付款、处理服务请求、学生注册、实施医疗程序或处理理赔等。为了识别组织的业务流程，了解几个<strong>共同特征</strong>会很有帮助：</p> <ul><li>业务流程通常用动作动词来表达，因为它们代表了企业所执行的活动。与之相关的维度描述了每个业务流程事件的描述性上下文。</li> <li>业务流程通常由某个运营系统提供支持，如计费系统或采购系统。</li> <li>业务流程生成或捕获关键绩效指标。有时这些指标是业务流程的直接结果，有时则是推导出来的测量值。分析人员总是希望通过看似无穷无尽的过滤器和约束条件组合来仔细审查和评估这些指标。</li> <li>业务流程通常由某个输入触发，并产生输出指标。在许多组织中，存在一系列流程，其中一个流程的输出会成为下一个流程的输入。用维度建模人员的话来说，这一系列流程会产生一系列事实表。</li></ul> <p>你需要仔细倾听业务需求，以识别组织的业务流程，因为业务用户无法轻易回答 “你对哪个业务流程感兴趣？” 这个问题。用户在数据仓库/商业智能（DW/BI）系统中想要分析的绩效测量结果来自业务流程事件。</p> <p>有时业务用户谈论的是战略业务计划，而非业务流程。这些计划通常是由执行领导层倡导的广泛的企业计划，旨在提供竞争优势。为了将业务计划与代表DW/BI团队项目工作单元的业务流程联系起来，你需要将业务计划分解为底层流程。这意味着要更深入地挖掘，以了解支持该计划分析需求的数据和运营系统。</p> <p>同样值得注意的是，业务流程不是什么。组织中的业务部门或职能并不等同于业务流程。通过关注流程而非职能部门，可以更经济高效地在整个组织中传递一致的信息。如果你设计的是与部门绑定的维度模型，必然会用不同的标签和数据值重复存储数据。确保数据一致性的最佳方法是只发布一次数据。</p> <h3 id="步骤2-声明粒度"><a href="#步骤2-声明粒度" class="header-anchor">#</a> 步骤2：声明粒度</h3> <p>声明粒度意味着准确指定单个事实表行所代表的内容。粒度传达了与事实表测量相关的详细程度，它回答了 “你如何描述事实表中的单个行？” 这个问题。粒度由捕获业务流程事件的运营系统的实际情况决定。</p> <p>例如，粒度声明包括：</p> <ul><li>客户销售交易中单个产品的每次扫描对应一行</li> <li>医生账单上的每个行项目对应一行</li> <li>机场登机口扫描的每张个人登机牌对应一行</li> <li>仓库中每个物品每日库存水平的快照对应一行</li> <li>每个银行账户每月对应一行</li></ul> <p>这些粒度声明都是用业务术语表达的。也许你原本期望粒度是事实表主键的传统声明方式。虽然粒度最终等同于主键，但列出一组维度然后就认为这是粒度声明是错误的。只要有可能，你应该用业务术语来表达粒度。</p> <p>维度建模人员有时会试图跳过这个看似不必要的四步设计流程中的步骤。请不要这样做！声明粒度是一个关键步骤，不能掉以轻心。多年来，在调试数千个维度设计时，最常见的错误就是在设计过程开始时没有声明事实表的粒度。如果粒度没有明确定义，整个设计就会像建立在流沙之上；关于候选维度的讨论将陷入循环，不相关的事实也会混入设计中。不合适的粒度会给DW/BI的实施带来麻烦！设计团队中的每个人就事实表的粒度达成一致极为重要。话虽如此，在设计过程的第3步或第4步中，你可能会发现粒度声明有误。这没关系，但你必须回到第2步，正确重新声明粒度，然后重新审视第3步和第4步。</p> <h3 id="步骤3-识别维度"><a href="#步骤3-识别维度" class="header-anchor">#</a> 步骤3：识别维度</h3> <p>维度源于 “业务人员如何描述业务流程测量事件产生的数据？” 这个问题。你需要用一组丰富的维度来修饰事实表，这些维度代表了在每次测量的背景下所有可能的描述，且每个维度在该测量中只取单一值。如果你对粒度有清晰的认识，通常很容易识别出维度，因为它们代表了与事件相关的 “谁、什么、在哪里、何时、为什么以及如何”。常见的维度示例包括日期、产品、客户、员工和设施。选择每个维度后，你要列出所有离散的、类似文本的属性，来充实每个维度表。</p> <h3 id="步骤4-识别事实"><a href="#步骤4-识别事实" class="header-anchor">#</a> 步骤4：识别事实</h3> <p>事实是通过回答 “这个流程在测量什么？” 这个问题来确定的。业务用户热衷于分析这些绩效指标。设计中的所有候选事实都必须与第 2 步中定义的粒度相符。明显属于不同粒度的事实必须放在单独的事实表中。典型的事实是数值型的可加数据，如订购数量或美元成本金额。</p> <p>在决定这四个步骤时，你需要同时考虑业务用户的需求和源数据的实际情况，如图 3 - 1 所示。我们<strong>强烈建议</strong>你抵制仅根据源数据进行数据建模的诱惑。直接研究数据可能看起来比与业务人员沟通更容易，但数据无法替代业务用户的意见。不幸的是，许多组织尝试了这种最省事的数据驱动方法，但收效甚微。</p> <h2 id="retail-case-study-零售案例研究"><a href="#retail-case-study-零售案例研究" class="header-anchor">#</a> Retail Case Study 零售案例研究</h2> <p>让我们从一个零售业务的简要描述开始。选择零售业作为首个案例，是因为这是大家都熟悉的行业。但本章讨论的模式几乎适用于任何行业的维度模型。</p> <p>假设你在一家大型连锁超市的总部工作。该业务在五个州拥有100家门店，每家门店设有完整的部门，包括杂货、冷冻食品、乳制品、肉类、农产品、烘焙、花卉和健康/美容用品。每家门店约有60,000种独立商品（称为库存单位，SKU）。</p> <p>数据在超市的多个关键环节被采集。最有价值的数据来自收银台，即顾客购买商品时的销售点（POS）系统。POS系统通过扫描商品条形码，测量超市前门的消费者购买行为，如图3-2的收银小票所示。其他数据则来自门店后门，即供应商送货处。</p> <p>超市管理层关注商品订购、库存和销售的物流管理，同时追求利润最大化。利润最终来自尽可能提高商品售价、降低采购和运营成本，并在高度竞争的环境中吸引更多顾客。其中，定价和促销是最重要的管理决策之一。总部营销和门店管理会花费大量时间调整定价和促销策略。商店管理层和总部营销团队都花费大量时间调整定价和促销活动。杂货店的促销手段包括临时降价、报纸广告及插页、店内陈列展示以及发放优惠券等。大幅降价是刺激产品销量激增的最直接有效的方法。比如，纸巾降价 50 美分，再加上广告和陈列展示，能使纸巾的销量增长 10 倍。然而，如此大幅度的降价通常难以持续，因为这可能导致产品亏本销售。因此，全面了解各种促销形式，对于分析杂货店的运营情况至关重要。</p> <p>在了解业务背景后，我们开始设计维度模型。</p> <h3 id="第一步-选择业务过程"><a href="#第一步-选择业务过程" class="header-anchor">#</a> 第一步：选择业务过程</h3> <p>设计的第一步是结合业务需求和可用数据源，确定要建模的业务过程。</p> <p><strong>注意</strong>：DW/BI系统的首个项目<strong>应</strong>聚焦于对业务用户最关键且最可行的业务过程。可行性包括数据可用性、质量及组织准备度等因素。</p> <p>在我们的零售案例研究中，管理层希望更好地了解 POS 系统记录的顾客购买情况。因此，要建模的业务流程是 POS 零售销售交易。这些数据能帮助业务用户分析哪些产品在哪些店铺、哪些日子、在何种促销条件下以及通过哪些交易进行销售。即这些数据让业务用户能够分析：
• 哪些商品在哪些门店的哪些日期售出
• 在哪些促销条件下售出
• 属于哪些交易</p> <h3 id="第二步-声明粒度"><a href="#第二步-声明粒度" class="header-anchor">#</a> 第二步：声明粒度</h3> <p>确定业务流程后，设计团队需要就粒度做出重要决策。维度模型中应提供何种详细程度的数据呢？</p> <p>从多个方面来看，处理最低原子粒度lowest atomic grain 的数据是合理的：</p> <ul><li>原子数据具有高度的维度性。事实测量越详细、越原子化，你能确定的信息就越多。这些确定的信息都可以转化为维度。从这个角度而言，原子数据与维度建模方法完美契合。</li> <li>原子数据提供了最大的分析灵活性，因为它可以以各种可能的方式进行约束和汇总。维度模型中的详细数据随时准备应对is poised and ready业务用户的临时查询the ad hoc attack。</li></ul> <p><strong>注意</strong>：你应该开发能够表示业务流程所捕获的最详细、原子化信息的维度模型。。</p> <p>（虽然可以声明更高层次的汇总粒度，但这会限制维度的数量和细节。汇总模型会立即面临用户“下钻”到细节的需求。用户无法从汇总数据反推细节，但可以轻松汇总原子数据。  ）当然，您可以声明一个更概括的粒度，表示原子数据的聚合。然而，一旦你选择了一个更高级别的粒子，你限制自己到较少和 / 或潜在的较少详细的维度。粒度较小的模型很容易受到意外的用户请求的影响，这些用户请求要深入研究细节。当不给用户访问原子数据的权限时，用户不可避免地会遇到分析障碍。尽管聚合数据在性能调优中扮演着重要角色，但它并不能替代让用户访问最底层的细节，用户可以轻松地汇总原子数据，但不可能从汇总数据中创建细节。不幸的是，一些行业专家仍然对这一点感到困惑。他们声称维度模型只适用于总结的数据，然后批评维度建模方法假定需要预测业务问题。当详细的原子数据在多维模型中可用时，这种误解就消失了。</p> <p>在我们的案例研究中，最细粒度的数据<strong>是</strong>销售点（POS）交易中的单个产品（假设POS系统将同一购物车中同一商品的所有销售合并为一行）。虽然用户（指的是数据仓库的用户）可能不关心<u>单笔交易中的某个商品</u>，但你无法预测他们未来会如何分析数据。例如：
• 比较周一和周日的销售差异
• 评估是否值得囤积某品牌的多种规格
• 分析洗发水降价50美分的促销效果
• 研究竞品促销期间本品牌销量的变化</p> <p>尽管这些查询都不需要特定某一笔交易的数据，但它们都是宽泛的问题，需要精确筛选的详细数据才能解答。如果只提供汇总数据，这些问题都无法得到答案。</p> <p><strong>注意</strong>：数据仓库 / 商业智能（DW/BI）系统几乎<strong>总是</strong>需要以尽可能低的粒度表达数据，这并非是因为查询需要查看单个行数据，而是因为查询需要以非常精确的方式筛选细节。</p> <h3 id="第三步-识别维度"><a href="#第三步-识别维度" class="header-anchor">#</a> 第三步：识别维度</h3> <p>在选择了事实表的粒度之后，维度的选择就变得简单明了。产品和交易维度会自然浮现。在主要维度的框架the framework of the primary dimensions<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>内，你<strong>可以思考</strong>还有哪些维度可归因于 POS 测量，比如销售日期、销售发生的店铺、产品销售时的促销活动、处理销售的收银员，以及可能的支付方式。我们将此作为另一个<strong>设计原则</strong>。</p> <p>注意：精确的粒度声明careful grain statement决定了事实表的主要维度the primary dimensionality 。然后，如果这些额外维度additional dimensions在主要维度的每种组合下自然只取一个值，你就可以将其添加到事实表中。如果某个额外维度因导致生成额外的事实行而违反了粒度要求，则需要排除该维度，或者重新审视粒度声明。</p> <p>适用于本案例的描述性维度包括：日期、产品、店铺、促销、收银员和支付方式。此外，POS 交易单号也作为一个特殊维度，本章后面的 “交易编号的退化维度” 部分会对此进行介绍。</p> <p>在为维度表填充fleshing out 描述性属性descriptive attributes, 之前，让我们先完成四步流程的最后一步。在设计的这个阶段at this stage of the design，不要因关注细节而忽略了整体don’t want to lose sight of the forest for the trees。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>: primary dimension相对于外伸维度outrigger dimension。</p> <p>“primary dimension”指的是事实表周围直接关联的主要维度，它是构建维度模型的关键部分。以零售销售的维度模型为例，产品维度、商店维度、日期维度等都属于主要维度，这些维度直接与事实表相连，为事实表中的数据提供关键的描述性上下文信息。</p> <p>在涉及外伸维度（outrigger）的场景中，“primary dimension”尤为重要。如上述内容提到，外伸维度是从主要维度衍生出来的，像从主要维度的日期属性中分离出的外伸日期维度。这一外伸维度的日期属性会被特别标注，以便和业务流程中其他常规的日期属性区分开来。只有当业务需求涉及到依据非标准日历属性（如财政周期、工作日指标或节假日期间）对日期进行筛选和分组时，从主要维度表的日期属性创建外伸维度才有意义。在这种情况下，主要维度作为基础，为外伸维度提供了关联和数据支撑。若没有此类特殊需求，相关日期属性直接作为产品维度中的标准日期类型列处理即可 。</p> <h3 id="第四步-识别事实"><a href="#第四步-识别事实" class="header-anchor">#</a> 第四步：识别事实</h3> <p>设计中的第四步，也是最后一步，是仔细确定哪些事实将出现在事实表中。同样，粒度声明有助于明确思路。简而言之，事实必须与粒度相符，在本案例中即 POS 交易中的单个产品行项目。在考虑潜在事实时，你可能会再次发现<strong>需要</strong>对之前的粒度假设或维度选择进行调整。</p> <p>POS 系统收集的事实包括：</p> <ul><li>销售数量（例如鸡肉面汤的罐数 ）、单位常规价格、折扣价格和净支付价格，以及扩展折扣金额和销售美元金额。</li> <li>扩展销售美元金额等于销售数量乘以净单位价格。同样，扩展折扣美元金额是销售数量乘以单位折扣金额。</li> <li>一些先进的 POS 系统还会提供供应商交付到商店的产品的标准美元成本。假设这个成本事实很容易获取，并且不需要进行复杂的基于活动的成本核算，那么你可以将扩展成本金额包含在事实表中。</li></ul> <p>事实表的雏形如图 3 - 3 所示。</p> <p>销售数量、扩展折扣金额、销售金额和成本金额这四个事实在所有维度上都具有良好的可加性。你可以不受限制地根据维度属性对事实表进行切片和切块分析，并且这四个事实的每一个总和都是有效且正确的。</p> <p><strong>派生事实</strong></p> <p>你可以通过从扩展销售美元金额（即收入）中减去扩展成本美元金额来计算毛利润。尽管毛利润是计算得出的，但它在所有维度上也完全具有可加性；你可以计算任何一组商店在任何时间段内销售的任何产品组合的毛利润。维度建模人员有时会质疑是否应将计算得出的派生事实存储在数据库中。</p> <p>我们<strong>通常建议</strong>将其物理存储。</p> <ul><li>在本案例研究中，毛利润的计算很简单，但存储它意味着在 ETL（提取、转换、加载）过程中进行一致的计算，避免了用户计算错误的可能性。用户错误表示毛利润的成本远远超过了微小的增量存储成本。</li> <li>存储它还确保所有用户和 BI 报告应用程序对毛利润的引用是一致的。由于毛利润可以从单个事实表行中的相邻数据计算得出，有人会认为应该在与表无异的视图中进行计算。如果所有用户都通过该视图访问数据，并且没有使用临时查询工具的用户能够绕过该视图访问物理表，那么这是一种合理的方法。视图是在节省存储的同时最小化用户错误的合理方式，但数据库管理员<strong>必须</strong>确保不允许有任何绕过视图访问数据的情况。同样，一些组织希望在 BI 工具中进行计算。同样，如果所有用户都使用同一个工具访问数据，这种方法可行，但根据我们的经验，这种情况很少见。然而，有时报告中的非可加性指标（如百分比或比率）必须在 BI 应用程序中计算，因为这些计算无法预先计算并存储在事实表中。OLAP（在线分析处理）立方体在这种情况下表现出色。</li></ul> <p>不可加事实</p> <p>毛利率可以通过毛利润除以扩展销售美元收入来计算。毛利率是一个非可加事实，因为它不能沿任何维度进行汇总。在计算任何一组产品、商店或日期的毛利率时，需要分别先对收入和成本进行求和，然后再做除法。</p> <p>注意：百分比和比率，比如毛利率，属于非可加事实。分子和分母应存储在事实表中。然后可以在 BI 工具中针对事实表的任何切片计算比率，记住要计算总和的比率，而不是比率的总和。</p> <p>单价是另一个非可加事实。与事实表中的扩展金额不同，对单价在任何维度上进行求和都会得到一个毫无意义的数字。举个简单的例子：你以 1 美元的单价卖出一个小部件，又以每个 50 美分的单价卖出四个小部件。你可以将销售数量相加，得出共卖出了五个小部件；同样，你可以将销售美元金额（1 美元和 2 美元）相加，得出总销售额为 3 美元。然而，你不能将单价（1 美元和 50 美分）相加，并宣称总单价为 1.5 美元；同样，你也不应说平均单价是 75 美分。正确的加权平均单价应该是用总销售额（3 美元）除以总数量（五个小部件），得出平均单价为 60 美分。仅查看每个交易行的单价是无法得出这个结论的。要分析平均价格，你必须先将销售美元金额和销售数量相加，然后用总金额除以总销售数量。幸运的是，许多 BI 工具都能正确执行此功能。有人会质疑非可加事实是否应该物理存储在事实表中。考虑到除了在报告上打印单个值或直接对事实应用筛选器（这两种情况都不常见）之外，它们的分析价值有限，这个问题是合理的。在某些情况下，源系统会提供像温度这样的基本非可加事实。如果业务分析师认为有意义，这些非可加事实可以在多个记录上进行仔细平均。</p> <p>事务事实表</p> <p>事务性业务流程是最常见的。表示这些流程的事实表具有几个共同特征：</p> <ul><li>原子事务粒度事实表的粒度可以在事务的上下文中简洁地表达，例如每个事务一行或每个事务行项目一行。</li> <li>由于这些事实表记录事务性事件，它们通常是稀疏填充的。在我们的案例研究中，显然我们不会在每个购物车中销售所有产品。</li> <li>尽管事务事实表的填充是不可预测且稀疏的，但它们可能会非常庞大。数据仓库中大多数包含数十亿甚至数万亿行的表都是事务事实表。</li> <li>事务事实表往往具有很高的维度性。</li> <li>只要事务性事件产生的指标是通过数量进行扩展的，而不是捕获每单位的指标，它们通常是可加的。</li></ul> <p>在设计的早期阶段，估计最大的表（即事实表）中的行数通常很有帮助。在本案例研究中，这可能只需要与源系统专家沟通，了解定期生成的 POS 交易行项目数量即可。零售业的流量每天波动很大，所以你需要了解合理时间段内的交易活动情况。或者，你可以通过将连锁店的年总收入除以平均商品售价来估计每年添加到事实表中的行数。假设年总收入为 40 亿美元，而顾客购物小票上商品的平均价格为 2 美元，那么你可以计算出每年大约有 20 亿个交易行项目。这是一个典型的工程估算方法，能让你在无需复杂操作的情况下，大致确定设计规模。作为设计师，你应该始终多方面验证，以确保你的计算是合理的。</p> <h2 id="维度表详细信息"><a href="#维度表详细信息" class="header-anchor">#</a> 维度表详细信息</h2> <p>现在我们已经完成了四步流程，让我们回到维度表，专注于用丰富的属性填充它们populating them with robust attributes。</p> <h3 id="日期维度"><a href="#日期维度" class="header-anchor">#</a> 日期维度</h3> <p>日期维度是一个特殊的维度，因为<strong>几乎可以肯定</strong>，它存在于每一个维度模型中，因为几乎每个业务流程都会捕获绩效指标的时间序列。实际上，日期通常是数据库底层分区方案中的第一个维度，这样连续的时间间隔数据加载就可以存储在磁盘的新区域the successive time interval data loads are placed into virgin territory on the disk<a href="%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%A7%A3%E9%87%8A">^3.3.1-1</a>。</p> <p>对于读过《数据仓库工具箱》（Wiley，1996 年第一版）的读者来说，这个维度曾被称为时间维度。然而，在过去的十多年里，我们一直用 “日期维度” 来表示按日粒度的维度表，这有助于区分日期date和时间time-of-day维度。</p> <p>与大多数其他维度不同，你<strong>可以</strong>提前构建日期维度表。你可以在表中插入代表 10 年或 20 年的每一天的行，这样就能涵盖已存储的历史数据以及未来几年的数据。即使是 20 年的天数，大约也只有 7300 行，这是一个相对较小的维度表。对于零售环境中的每日日期维度表，我们建议包含图 3 - 4 中所示的部分列。</p> <p>每个日期维度表中的列都是由该行所代表的特定日期定义的。例如，</p> <ul><li>星期几列包含当天的名称，如星期一，该列可用于创建比较周一和周日业务情况的报告。</li> <li>日历月中的日期编号列从每个月的 1 开始，根据月份不同，该数字会一直增加到 28、29、30 或 31，此列对于比较每个月的同一天很有用。</li> <li>类似地，你可以有一个年份中的月份编号列（1 到 12）。所有这些整数都支持跨年份和月份边界的简单日期运算。</li></ul> <p>为了便于报告，你<strong>应该</strong>同时包含长标签和缩写标签both long and abbreviated labels。例如，</p> <ul><li>你会希望有一个月份名称属性，其值如 “January”。</li> <li>此外，年份 - 月份（YYYY - MM）列可用作报告列标题。</li> <li>你可能还需要一个季度编号（Q1 到 Q4），以及年份 - 季度，如 2013 - Q1。</li> <li>如果财年期间与日历年期间不同，你也应该包含类似的财年期间列。图 3 - 5 展示了包含几个日期维度列的示例行。</li></ul> <p>注意：本书的示例日期维度可在<a href="https://www.kimballgroup.com/" target="_blank" rel="noopener noreferrer">www.kimballgroup.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的 “Tools and Utilities”（工具和实用程序）选项卡下获取。</p> <p>有些设计师此时可能会问，<strong>为什么</strong>需要一个<u>明确的日期维度表</u><a href="%E8%BF%99%E9%87%8C%E7%9A%84%E2%80%98%E6%98%8E%E7%A1%AE%E7%9A%84%E6%97%A5%E6%9C%9F%E7%BB%B4%E5%BA%A6%E8%A1%A8%E2%80%99%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E2%80%98%E7%A1%AE%E5%AE%9A%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E6%97%A5%E6%9C%9F%E7%9A%84%E7%BB%B4%E5%BA%A6%E8%A1%A8%E2%80%99%E8%80%8C%E4%B8%8D%E6%98%AF%E2%80%98%E5%9C%A8%E4%BA%8B%E5%AE%9E%E8%A1%A8%E4%B8%AD%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%97%A5%E6%9C%9F%E9%94%AE%E2%80%99">^3.3.1-2</a>。</p> <ul><li>他们认为，如果事实表中的日期键是日期类型的列，那么任何 SQL 查询都可以直接对事实表的日期键进行约束，并使用自然的 SQL 日期语义来过滤月份或年份，从而避免进行可能代价高昂的连接操作。但这种想法存在几个问题。首先，如果你的关系数据库无法高效地连接到日期维度表，那你就麻烦了。大多数数据库优化器在解析维度查询方面都相当高效，没必要像躲避瘟疫一样避免连接操作<a href="%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%A7%A3%E9%87%8A">^3.3.1-3</a>。</li> <li>由于普通业务用户并不熟悉 SQL 日期语义，他们无法请求典型的日历分组。SQL 日期函数不支持按工作日与周末、节假日、财年期间或季节等属性进行过滤。假设业务需要按这些非标准日期属性对数据进行切片，那么一个明确的日期维度表就至关重要。日历逻辑应该放在维度表中，而不是应用程序代码中。</li></ul> <p>注意：维度模型总是需要一个明确的日期维度表。有许多日期属性是 SQL 日期函数不支持的，包括周数、财年期间、季节、节假日和周末。与其在查询中尝试确定这些非标准的日历计算，不如在日期维度表中查找。</p> <p><strong>标志和指标作为文本属性</strong></p> <p>与许多操作标志和指标一样，日期维度的节假日指标是一个简单的指标，有两个可能的值。由于维度表属性用作<u>报告标签和下拉查询过滤器列表中的值</u>，这个指标<strong>应该</strong>用有意义的值填充，如 “Holiday”（节假日）或 “Non - holiday”（非节假日），而不是使用晦涩的 Y/N、1/0 或 True/False。如图 3 - 6 所示，假设要生成一份比较某产品在节假日和非节假日销售额的报告。这个指标使用更有意义的域值，会使报告更有意义、更易于理解。我们倾向于将<u>解码后的值</u>存储在数据库中，这样无论用户使用何种 BI 报告环境或工具，这些值都能一致地提供给所有用户，而不是在 BI 应用程序中对标志进行解码以获得可理解的标签。</p> <p>类似地，工作日指标也应该有 “Weekday”（工作日）或 “Weekend”（周末）这样的值。显然，周六和周日会被赋予周末值。当然，多个日期表属性可以联合约束，这样你就可以轻松比较工作日节假日和周末节假日的情况。</p> <p><strong>当前和相对日期属性</strong></p> <p>大多数日期维度属性不会被更新。2013 年 6 月 1 日始终属于 6 月、日历第二季度和 2013 年。然而，你<strong>可以</strong>向基本日期维度添加一些<u>随时间变化的属性</u>，</p> <ul><li>包括 “IsCurrentDay”（是否为当前日）、“IsCurrentMonth”（是否为当前月）、“IsPrior60Days”（是否在过去 60 天内）等。</li> <li>“IsCurrentDay” 显然每天都需要更新；这个属性对于生成每日报告很有用。需要考虑的一个细微之处是 “IsCurrentDay” 所指的日期。大多数数据仓库每天加载数据，所以 “IsCurrentDay” 通常指的是昨天（或者更准确地说，是最近加载数据的那一天）。</li> <li>你也可以向日期维度添加一些u，比如 “IsFiscalMonthEnd”（是否为财月末）。</li></ul> <p>有些日期维度包含更新的滞后属性。滞后天数列在当天的值为 0，昨天为 - 1，明天为 + 1，依此类推。这个属性可以很容易地设置为计算列，而不是物理存储。你也可以为月份、季度和年份设置类似的结构。许多 BI 工具都具备进行前期计算的功能，所以这些滞后列可能<strong>并非必需</strong>。</p> <p><strong>Time-of-Day作为维度或事实</strong></p> <p>虽然在操作日期 / 时间戳中，日期和时间是混合在一起的，但<strong>通常</strong>会将Time-of-Day与日期维度分开，以避免日期维度中的行数暴增。如前所述，包含 20 年历史数据的日期维度大约有 7300 行。如果你将这个维度的粒度更改为每天每分钟一行，那么为了容纳每天 1440 分钟，最终会有超过 1000 万行数据。如果精确到秒，每年就会有超过 3100 万行数据！由于日期维度可能是模式中最常被约束的维度（日期常被作为where中的条件进行查询），所以应该尽量保持其规模较小且易于管理。</p> <p>如果你想根据汇总的时段分组（比如 15 分钟间隔、小时、班次、午餐时间或黄金时段的活动）对时间段进行过滤或汇总，那么Time-of-Day 应被视为一个完整的维度表，每个离散的时间段对应一行，比如 24 小时内每分钟对应一行，这样就会生成一个包含 1440 行的维度表。</p> <p>如果不需要按Time-of-Day分组进行汇总或过滤，Time-of-Day <strong>应</strong>作为事实表中的简单日期 / 时间事实处理<a href="%E4%B8%BE%E4%BE%8B">^3.3.1-4</a>。顺便说一句，业务用户<strong>通常</strong>对时间滞后time lags（比如交易持续时间）更感兴趣，而不是离散的开始和结束时间。时间滞后可以通过计算日期 / 时间戳之间的差值轻松得出。这些日期 / 时间戳还能让应用程序确定两个感兴趣的交易之间的时间间隔，即使这些交易发生在不同的日期、月份或年份。</p> <ul><li>这句话的因果关系。‘由于’日期维度几乎存在于每一个维度模型中，且几乎每个业务流程都会捕获绩效指标的时间序列，‘所以’日期通常是数据库底层分区方案中的第一个维度。‘这就使得’连续的时间间隔数据加载可以存储在磁盘的新区域，即 “virgin territory on the disk”，这样做有助于数据的有序存储和管理，比如方便后续对数据按时间进行处理、查询等操作1。</li> <li>可以把数据库想象成一个巨大的仓库，磁盘空间就是仓库里的存储空间，数据则是存放在这个仓库里的货物。</li> <li><strong>连续的时间间隔数据加载</strong>：业务会不断产生新数据，这些数据是按照时间顺序，一批一批地加载到数据库中的。例如，每天的销售数据、每小时的网站访问数据等。这些按时间顺序，在不同时间点加载的数据，就是“连续的时间间隔数据加载”。</li> <li><strong>存储在磁盘的新区域</strong>：在数据库这个“仓库”里，日期维度起到了一个特殊作用。它就像是仓库里划分区域的一个重要依据，把按照时间顺序来的数据，依次放到仓库里还没用过的地方，也就是“磁盘的新区域” 。这样做能让数据存储更有条理，查找和管理起来更方便。比如，新一个月的销售数据，就可以存放在专门为这个月预留的、之前没用过的磁盘空间里。</li></ul> <ul><li>大多数数据库优化器在处理维度查询方面其实相当高效，连接操作并非像这些设计师认为的那样需要极力避免。如果数据库连与日期维度表的高效连接都无法实现，那说明数据库本身在处理这类常见操作时存在严重缺陷，会影响整个数据处理和分析流程。比如在零售销售案例中，若无法高效连接日期维度表，业务用户分析不同时间段的销售数据时就会遇到困难。</li> <li>从数据仓库和维度建模的整体架构来看，日期维度表是不可或缺的。它不仅仅是简单的联表查询问题，其存在是为了满足复杂的业务分析需求。日期维度表包含了丰富的日期属性，像周数、财年期间、季节、节假日和周末等，这些是 SQL 日期函数无法支持的。若数据库不能高效连接日期维度表，就无法充分利用这些属性进行数据分析。</li></ul> <p>在零售销售的业务场景中，涉及time-of-day作为维度或事实的相关表和查询如下：</p> <p><strong>time-of-day作为维度表</strong>：</p> <ul><li><strong>维度表结构示例</strong>：</li></ul> <table><thead><tr><th>TIME-of-day维度表</th> <th>说明</th></tr></thead> <tbody><tr><td>time-of-day键（PK）</td> <td>唯一标识每个时间间隔的代理键</td></tr> <tr><td>具体时间间隔（如00:00 - 00:15）</td> <td>代表离散的时间区间，用于精确区分不同时段</td></tr> <tr><td>时段描述（如凌晨、早高峰等）</td> <td>对该时间间隔的文字描述，方便理解和使用</td></tr> <tr><td>时段分组（如夜间、白天等）</td> <td>根据业务需求对时间间隔进行的分组，用于更宏观的分析</td></tr></tbody></table> <ul><li><strong>查询示例</strong>：假设业务用户想了解早高峰时段（如07:00 - 09:00）内不同产品的销售情况。以零售销售事实表和time-of-day维度表为例，SQL查询可能如下：</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> p<span class="token punctuation">.</span>product_description<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span>extended_sales_dollar_amount<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_sales
<span class="token keyword">FROM</span> retail_sales_fact rs
<span class="token keyword">JOIN</span> time_of_day_dimension tod <span class="token keyword">ON</span> rs<span class="token punctuation">.</span>time_of_day_key <span class="token operator">=</span> tod<span class="token punctuation">.</span>time_of_day_key
<span class="token keyword">JOIN</span> product_dimension p <span class="token keyword">ON</span> rs<span class="token punctuation">.</span>product_key <span class="token operator">=</span> p<span class="token punctuation">.</span>product_key
<span class="token keyword">WHERE</span> tod<span class="token punctuation">.</span>time_interval <span class="token operator">BETWEEN</span> <span class="token string">'07:00:00'</span> <span class="token operator">AND</span> <span class="token string">'09:00:00'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> p<span class="token punctuation">.</span>product_description<span class="token punctuation">;</span>
</code></pre></div><p><strong>time-of-day作为事实表中的事实</strong>：</p> <ul><li><strong>事实表结构示例</strong>：在零售销售事实表中添加时间-of-day相关的日期/时间戳列。</li></ul> <table><thead><tr><th>零售销售事实表</th> <th>说明</th></tr></thead> <tbody><tr><td>日期键（FK）</td> <td>关联日期维度表的外键</td></tr> <tr><td>产品键（FK）</td> <td>关联产品维度表的外键</td></tr> <tr><td>商店键（FK）</td> <td>关联商店维度表的外键</td></tr> <tr><td>销售数量</td> <td>产品的销售数量</td></tr> <tr><td>扩展销售金额</td> <td>销售金额的扩展值</td></tr> <tr><td>交易时间戳（时间-of-day作为事实）</td> <td>记录交易发生的具体时间，可精确到时分秒</td></tr></tbody></table> <ul><li><strong>查询示例</strong>：若想计算每笔交易的时长（假设已知交易结束时间戳和开始时间戳），SQL查询可能如下：</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> rs<span class="token punctuation">.</span>pos_transaction_number<span class="token punctuation">,</span>
       <span class="token punctuation">(</span>rs<span class="token punctuation">.</span>end_transaction_timestamp <span class="token operator">-</span> rs<span class="token punctuation">.</span>start_transaction_timestamp<span class="token punctuation">)</span> <span class="token keyword">AS</span> transaction_duration
<span class="token keyword">FROM</span> retail_sales_fact rs<span class="token punctuation">;</span>
</code></pre></div><p>在实际应用中，根据业务需求的不同，time-of-day的处理方式及相关的表结构和查询会有所变化。</p> <ul><li>time-of-day作为维度表更适合用于对时间进行分组和分析的场景；</li> <li>作为事实表中的事实则更侧重于记录具体时间信息，用于计算时间相关的指标 。</li></ul> <h3 id="产品维度"><a href="#产品维度" class="header-anchor">#</a> 产品维度</h3> <p>产品维度描述了杂货店中的每一个 SKU。虽然一家典型的商店可能库存 60,000 个 SKU，但考虑到<u>不同的商品销售策略以及不再销售的历史产品</u>，产品维度可能会有 300,000 行或更多。产品维度几乎总是来源于操作产品主文件。大多数零售商在总部管理他们的产品主文件，并定期将一个子集下载到每个商店的 POS 系统中。总部负责为每个新产品定义合适的产品主记录（以及唯一的 SKU 编号）。</p> <p><strong>Flatten Many-to-One Hierarchies 将多对一层级扁平化</strong></p> <p>产品维度代表了每个 SKU 的众多描述性属性。商品层次结构the merchandise hierarchy是一组重要的属性。通常，单个 SKU 归属于品牌，品牌归属于类别，类别归属于部门。这些都是多对一的关系。图 3 - 7 展示了部分产品的商品层次结构及其他属性。</p> <p>对于每个 SKU，商品层次结构的所有级别都有明确的定义all levels of the merchandise hierarchy are well defined<a href="%E4%B8%BE%E4%BE%8B">^3.3.2-1</a>。有些属性，比如 SKU 描述，是唯一的。在这种情况下，SKU 描述列中有 300,000 个不同的值。另一方面，部门属性可能只有大约 50 个不同的值。因此，平均来说，部门属性中每个唯一值会重复 6,000 次。这<strong>完全没问题</strong>！你不需要为了节省空间将这些重复的值分离到第二个规范化表中。请记住，<strong>与事实表的空间需求相比，维度表的空间需求微不足道。</strong></p> <p>注意：将重复的低基数数值保留在主维度表中是一种基本的维度建模技术。将这些值规范化到单独的表中会违背简单性和性能这两个主要目标，本章后面的 “抵制规范化冲动” 部分会对此进行讨论。</p> <p>产品维度表中的许多属性不属于商品层次结构。包装类型属性可能有 “Bottle”（瓶）、“Bag”（袋）、“Box”（盒）或 “Can”（罐）等取值。任何部门的任何 SKU 都可能具有这些值之一。</p> <p>通常，将对这个属性的约束与对商品层次结构属性的约束结合起来是有意义的。例如，你可以查看谷物类别中所有袋装的 SKU。换句话说，你可以浏览维度属性，无论它们是否属于商品层次结构。产品维度表通常有不止一个明确的层次结构。</p> <p>图 3 - 8 展示了一个推荐的零售杂货店维度模型的部分产品维度。</p> <p><strong>Attributes with Embedded Meaning 具有隐含意义的属性</strong></p> <p>通常，在维度表中<u>用 NK（自然键）<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>表示的操作产品代码</u>具有隐含含义，代码的不同部分代表产品的重要特征。在这种情况下，多部分属性the multipart attribute应在维度表中完整保留，同时将其分解为各个组成部分，并作为单独的属性处理。例如，如果操作代码的第 5 到第 9 个字符标识制造商，那么制造商的名称也应作为维度表属性包含在内[^3.3.2-2]。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>: 学个英语。NK（自然键），the NK notation for natural key</p> <p><strong>Numeric Values as Attributes or Facts 数值作为属性或事实</strong></p> <p>你有时会遇到一些数值，它们<strong>并不明确</strong>属于事实或维度属性类别。一个典型的例子是产品的标准标价。它显然是一个数值，所以最初的想法可能是将其放在事实表中。但通常标准价格变化不频繁，这与大多数事实不同，大多数事实在每次测量事件中的值往往不同。</p> <ul><li>如果数值主要用于计算，那么它可能属于事实表。由于标准价格是非可加的，你可能会将其乘以数量得到一个可加的扩展金额。或者，如果标准价格主要用于价格差异分析，也许应该将差异指标存储在事实表中。</li> <li>如果稳定的数值主要用于过滤和分组，那么它应该被视为产品维度属性。</li> <li>有时数值同时具有计算和过滤 / 分组功能。在这些情况下，你<strong>应该</strong>在事实表和维度表中都存储该值。也许事实表中的标准价格代表销售交易时的估值，而维度属性则标记为当前标准价格。</li></ul> <p>注意：既用于事实计算，又用于维度约束、分组和标记的数据元素，<strong>应该</strong>在两个位置都进行存储，即使聪明的程序员可以编写从单个位置访问这些数据元素的应用程序。重要的是，维度模型应尽可能保持一致，应用程序开发<strong>应</strong>简单可预测。参与计算的数据应放在事实表中，而参与约束、分组和标记的数据应放在维度表中。</p> <p><strong>Drilling Down on Dimension Attributes 深入挖掘维度属性</strong></p> <p>一个合理的产品维度表可能有 50 个或更多的描述性属性。每个属性都是约束和构建行标题标签的丰富来源。向下钻取只不过是从维度中请求<u>一个能提供更多信息的行标题</u>a row header from a dimension that provides more information。</p> <p>假设你有一份简单的报告，按部门汇总销售美元金额。如图 3 - 9 所示，如果你想向下钻取，可以从产品维度中拖动任何其他属性（比如品牌）到报告中部门旁边，这样就可以自动向下钻取到下一个详细级别。你甚至可以按脂肪含量属性向下钻取，即使它不属于商品层次结构的汇总。</p> <p>注意：在维度模型中向下钻取只不过是从维度表中‘添加’行标题属性。向上钻取则是‘删除’行标题。你可以在多个明确的层次结构的属性上进行向下或向上钻取，也可以在不属于任何层次结构的属性上进行操作。</p> <p>产品维度是许多维度模型中的常见维度。<strong>应该</strong>非常小心地用尽可能多的描述性属性来填充这个维度。一套强大而完整的维度属性为业务用户提供了强大而完整地分析能力。我们将在第5章“采购”中进一步探讨产品维度，其中我们还将讨论产品属性更改的处理。</p> <p>在零售行业的产品维度中，商品层次结构的各级都有明确的定义。例如，在一家大型杂货店的产品维度里：</p> <ul><li><strong>个体商品（SKU）层面</strong>：每一种具体的商品，像 “Baked Well Light Sourdough Fresh Bread”（烘焙全麦酸面包）就是一个SKU，它有独特的SKU编号、产品描述等属性。</li> <li><strong>品牌层面</strong>：众多SKU会归属于相应的品牌，“Baked Well Light Sourdough Fresh Bread” 属于 “Baked Well” 品牌，该品牌下可能还有其他不同规格或口味的同品牌产品。</li> <li><strong>类别层面</strong>：品牌又会进一步归属于特定类别，“Baked Well” 品牌下的面包类产品都属于 “Bread”（面包）类别 。</li> <li><strong>部门层面</strong>：类别再往上归属于部门，“Bread” 类别属于 “Bakery”（烘焙食品）部门。</li></ul> <p>从这个例子可以看出，“Baked Well Light Sourdough Fresh Bread” 很明确地属于个体商品级别而不是其它级别， “Baked Well” 很明确地属于品牌级别而不是其它级别，这就是 “all levels of the merchandise hierarchy are well defined” 的体现 。这种明确的层次结构有助于在数据分析时进行高效的分组、筛选和汇总操作，比如可以方便地统计 “Bakery” 部门下 “Baked Well” 品牌的所有产品的销售数据。</p> <p>假设在一家电子产品公司的维度建模中，产品的操作型代码为 “ABC12345DEF”，这是一个包含嵌入式含义的产品自然键（NK）。根据文本中的内容，在维度表中处理这种代码的方式如下：</p> <ul><li>完整保留操作型代码：在维度表中，应完整保留 “ABC12345DEF” 这个产品代码，以便在需要时可以回溯到原始的操作型数据。</li> <li>分解代码的组成部分：假设该代码的第五到第九个字符 “12345” 用于识别产品的制造商。按照文本建议，除了保留完整代码，还应将制造商的名称作为一个单独的维度表属性添加到维度表中。如果 “12345” 对应的制造商是 “XYZ Electronics”，那么在维度表中就会有一个名为 “制造商名称” 的属性，其值为 “XYZ Electronics”。</li></ul> <p>通过这种方式，既保留了原始的操作型代码，又将代码中具有含义的部分提取出来作为独立的属性，方便用户在进行数据分析时，既可以使用完整代码进行精确查询，也可以通过制造商名称等分解后的属性进行数据筛选、分组和分析，从而更好地理解和利用数据。</p> <h3 id="商店维度"><a href="#商店维度" class="header-anchor">#</a> 商店维度</h3> <p>商店维度描述了连锁杂货店中的每一家商店。与几乎在每个大型杂货业务中都能找到的‘产品主文件’不同，可能并不存在一个全面的‘商店主文件’。POS 系统可能只是在交易记录中提供一个商店编号。在这些情况下，项目团队<strong>必须</strong>从多个操作源收集商店维度所需的组件。通常总部会有一个商店房地产部门，他们会帮助定义详细的商店主文件。</p> <p><strong>维度表中的多个层次结构</strong></p> <p>Multiple Hierarchies in Dimension Tables</p> <p>商店维度是本案例研究中的<strong>主要</strong>地理维度。每家商店都可以被视为一个位置。你可以将商店按任何地理属性进行汇总，比如美国的邮政编码、县和州。<strong>与普遍看法相反</strong>，美国的城市和州并不构成层次结构。由于许多州都有同名的城市，所以你可能需要在商店维度中包含一个城市 - 州属性。</p> <p>商店也可能按‘内部组织层次结构’进行汇总，包括商店区域和地区。这两种不同的商店层次结构都可以很容易地在维度中表示，因为对于单个商店行来说，地理和组织层次结构都有明确的定义。</p> <p>注意：在维度表中表示多个层次结构<strong>并不罕见</strong>。多个层次结构中的属性名称和值应该是唯一的。</p> <p>图 3 - 10 展示了一个推荐的零售商店维度表。</p> <p>楼层平面图类型、照片冲印类型和金融服务类型都是描述特定商店的短文本描述符。这些不应是单字符代码，而应该是 10 到 20 个字符的描述，以便在下拉筛选列表中查看或用作报告标签时具有实际意义。</p> <p>描述‘销售面积’的列是数值型的，理论上可以在商店之间进行累加。你可能会想把它放在事实表中。然而，它显然是商店的一个常量属性，更多地用于约束或标记，而不是作为求和中的可加元素。基于这些原因，销售面积应属于商店维度表。</p> <p><strong>维度表中的日期</strong></p> <p>商店维度中的‘首次开业日期’和‘上次翻新日期’可以是日期类型的列。然而，如果用户希望按非标准日历属性（比如开业日期的财年期间）进行分组和约束，那么它们通常是与日期维度表副本的连接键。这些日期维度副本在 SQL 中通过视图构造进行声明，在语义上与主日期维度不同。视图声明如下所示：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">view</span> first_open_date <span class="token punctuation">(</span>first_open_day_number<span class="token punctuation">,</span> first_open_month<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token keyword">as</span> <span class="token keyword">select</span> day_number<span class="token punctuation">,</span> <span class="token keyword">month</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token keyword">from</span> <span class="token keyword">date</span>
</code></pre></div><p>现在，系统就像有另一个名为FIRST_OPEN_date的日期维度表的物理副本一样。</p> <ul><li>这个新日期表的约束与连接到事实表的主日期维度的约束无关。</li> <li>first_open_date视图是商店维度的允许延伸a permissible <strong>outrigger</strong> to the store dimension；本章稍后将更详细地描述外伸支架outrigger。</li> <li>请注意，我们已经仔细地重新标记了视图中的所有列，这样它们就不会与主日期维度中的列混淆。</li> <li>单个物理日期维度上的这些不同逻辑视图是‘维度角色扮演’的一个例子，我们将在第6章：订单管理中更全面地讨论。</li></ul> <h3 id="促销维度"><a href="#促销维度" class="header-anchor">#</a> 促销维度</h3> <p>促销维度可能是零售销售模式中最有趣的维度。促销维度描述了产品销售时的促销条件，促销条件包括临时降价、端架展示、报纸广告和优惠券等。这个维度通常被称为‘因果维度’，因为它描述了<u>被认为会导致产品销售变化的因素</u>。</p> <p>总部和门店的业务分析师都对确定促销活动是否有效感兴趣。评估促销活动通常基于以下一个或多个因素：</p> <ul><li>在促销期间，促销产品的销售额是否有所增长，即所谓的 “提升”。只有当商店能够确定<u>促销产品在没有促销活动时的基线销售额</u>时，才能衡量这种提升。基线值可以根据先前的销售历史进行估算，在某些情况下，还可以借助复杂的模型来估算。</li> <li>促销产品在促销前或促销后的销售额是否下降，从而抵消了促销期间的销售额增长（即 “时间转移”）。换句话说，是否将常规定价产品的销售额转移到了临时降价产品上？</li> <li>促销产品的销售额是否增长，但货架附近的其他产品销售额却相应下降（即 “蚕食”）。</li> <li>考虑到促销前后的时间段，促销产品类别的所有产品的整体销售额是否有净增长（即 “市场增长”）。</li> <li>促销活动是否盈利。通常，促销活动的利润是指促销产品类别的利润相对于基线销售额的增量，同时考虑到时间转移、蚕食以及促销成本。</li></ul> <p>影响销售的因果条件不一定由‘POS系统’直接跟踪。</p> <ul><li>‘交易系统’会记录价格下调和折扣信息。</li> <li>由于顾客在销售时要么出示优惠券，要么不出示，所以优惠券的使用情况通常也会在‘交易’中记录下来。</li> <li>广告和店内展示条件可能需要从‘其他来源’进行关联。</li></ul> <p>各种可能的因果条件之间高度相关。临时降价通常与广告以及可能的端架展示end aisle display相关联。因此，为每一个出现的促销条件组合在促销维度中创建一行是<strong>合理</strong>的。在一年的时间里，可能会有1000个广告、5000次临时降价和1000个端架展示，但这些条件对任何特定产品的影响组合可能只有10000种。例如，在一次促销活动中，大多数商店会同时采用这三种促销机制，但少数商店可能不会设置端架展示。在这种情况下，就需要两个单独的促销条件行，一个用于正常的降价、广告、展示组合the normal price reduction plus ad plus display，另一个用于降价、广告的组合。图3 - 11展示了一个推荐的促销维度表。</p> <p>从纯粹的逻辑角度来看，你可以通过将四个因果机制（价格降低、广告、展示和优惠券）分离到单独的维度中，而不是将它们组合到一个维度中，来记录关于促销活动的类似信息。最终，这个选择<strong>取决于</strong>设计师的判断。支持将四个维度合并在一起的因素包括：</p> <ul><li>如果四个因果机制高度相关，那么合并后的单个维度并不比任何一个分离的维度大[^3.3.4-1]多少。</li> <li>合并后的单个维度可以高效地浏览，以查看各种价格降低、广告、展示和优惠券是如何组合使用的。然而，这种浏览只能显示可能的促销组合。在维度表中浏览并不能揭示哪些商店或产品受到了促销活动的影响；这些信息可以在事实表中找到。</li></ul> <p>支持将因果机制分离到<u>四个不同维度表</u>的因素包括：</p> <ul><li>如果用户分别考虑这些机制，那么分离的维度可能对业务群体来说更易于理解。这一点可以在业务需求访谈中体现出来。</li> <li>管理分离的维度可能比管理合并的维度更直接。</li></ul> <p>请记住，这两种选择在内容上没有区别[^3.3.4-2]。</p> <p>注意：在促销维度中包含促销成本属性时应谨慎考虑。这个属性可用于约束和分组。然而，这个成本不应出现在代表单个产品销售的POS交易事实表中，因为它的粒度不正确；这个成本必须存在于粒度为整体促销活动的事实表中。</p> <p><strong>外键、属性和事实为空</strong></p> <p>Null Foreign Keys, Attributes, and Facts</p> <p>通常，许多销售交易中都包含未促销的产品。</p> <ul><li>希望消费者不会只在购物车中装满促销产品；你希望他们为购物车中的一些产品支付全价！</li> <li>促销维度<strong>必须</strong>包含一行，其唯一键<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>可以是0或 - 1等，用于标识无促销条件，以避免事实表中出现空的促销键。</li> <li>如果在事实表中声明为指向维度表外键的列中填入空值，就会违反参照完整性。</li> <li>除了参照完整性警报外，空键会让用户感到非常困惑，因为他们无法对空键进行连接操作。</li></ul> <p>警告：必须避免事实表中出现空键。一个正确的设计应该在相应的维度表中包含一行，以标识该维度不适用于该测量。</p> <p>我们有时会遇到维度属性值为空的情况。这通常是由于<u>给定的维度行未完全填充</u>，或者<u>存在不能适用于该维度所有行的属性</u>。在这两种情况下，我们<strong>建议</strong>用 “Unknown”（未知）或 “Not Applicable”（不适用）等描述性字符串来代替空值。空值在可能的属性值下拉菜单或报告分组中基本上会消失；需要使用特殊语法才能识别它们。如果用户先<u>按一个已完全填充的维度属性对事实进行求和</u>，然后再<u>按一个有空值的维度属性进行求和</u>，他们会得到不同的查询结果<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>。这样你可能会接到电话，因为数据看起来不一致。与其让属性为空，或者用空格或句号代替，最好是对这种情况进行标记；这样用户就可以有意识地决定在查询中排除 “未知” 或 “不适用” 的情况。值得注意的是，一些OLAP产品禁止维度属性值为空，这也是避免空值的另一个原因。</p> <p>最后，我们也可能在事实表中遇到作为度量的空值。我们<strong>通常</strong>保留这些空值，以便它们在SUM、MIN、MAX、COUNT和AVG等聚合函数中得到正确处理，这些函数会对空值进行 “正确的处理”。用零代替空值会不适当地扭曲这些聚合计算。</p> <p>数据挖掘工具可能会使用不同的技术来处理空值。如果要为数据挖掘创建观察集an observation set<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>，可能需要在上述建议之外进行一些额外的转换工作。</p> <p>[^3.3.4-1]: “larger” 指的是维度表所包含的行数多少，即维度表规模大小。当考虑将价格削减、广告、展示和优惠券这四个因果机制合并为一个维度还是拆分为四个单独维度时，如果这四个因果机制高度相关，那么合并后的单一维度表所包含的行数，不会比将它们分开形成的任何一个单独维度表的行数多很多。这是因为高度相关意味着这些机制的组合情况相对有限，不会因组合而产生大量不同的维度行，所以合并后的维度表在规模上不会显著大于单独的维度表。维度表规模大小会影响数据存储和查询性能等，是设计维度模型时需要考虑的重要因素 。
[^3.3.4-2]: ‘内容上没有区别’指的是，无论采用哪种方式，所表达的关于促销条件的数据信息是一致的。</p> <p>唯一键是能唯一标识表中每一行记录的键。这个键不会查询出多个无促销的行数据吗？</p> <p>不会，在整个促销维度表的设计中，“无促销” 被视为一种特定的、统一的业务情况。从业务层面看，它是单一的概念，不需要用多个行来区分不同的 “无促销” 场景，所以仅用一个特殊键（如 0 或 -1）来标识这一种情况。</p> <p>假设这个特殊键是促销ID，在促销维度表里，不会存在多个行促销ID键都为0。</p> <p>以下为具体示例。在零售销售场景中，有销售事实表和促销维度表：</p> <table><thead><tr><th>销售事实表</th> <th>说明</th></tr></thead> <tbody><tr><td>销售交易ID</td> <td>主键，唯一标识每笔销售交易</td></tr> <tr><td>产品ID（外键）</td> <td>关联产品维度表，确定销售的产品</td></tr> <tr><td>商店ID（外键）</td> <td>关联商店维度表，确定销售发生的商店</td></tr> <tr><td>促销ID（外键）</td> <td><strong>关联促销维度表，若值为“0”或“–1”，表示该产品在此次销售中无促销；若为其他值，则对应具体促销活动</strong></td></tr> <tr><td>销售数量</td> <td>该产品的销售数量</td></tr> <tr><td>销售金额</td> <td>该产品的销售金额</td></tr> <tr><td>促销维度表</td> <td>说明</td></tr> <tr><td>----</td> <td>----</td></tr> <tr><td>促销ID</td> <td><strong>主键，“0”或“–1”代表无促销条件，其他值代表不同促销活动</strong></td></tr> <tr><td>促销名称</td> <td>若促销ID为“0”或“–1”，此处为“无促销”；若是其他值，则为对应促销活动的名称</td></tr> <tr><td>促销类型</td> <td>若为“0”或“–1”，无具体促销类型；其他值对应具体促销类型，如“满减”“折扣”等</td></tr> <tr><td>开始日期</td> <td>促销活动开始时间，“0”或“–1”对应无促销，无具体开始日期</td></tr> <tr><td>结束日期</td> <td>促销活动结束时间，“0”或“–1”对应无促销，无具体结束日期</td></tr></tbody></table> <p>在这个示例中，销售事实表通过“促销ID”外键关联促销维度表。当销售的产品没有参与促销时，销售事实表中的“促销ID”会记录为“0”或“–1”，这就对应促销维度表中代表“无促销”的那一行数据，从而避免了在事实表中出现空的促销键，保证了数据的参照完整性，也便于用户进行数据查询和分析，不会因空键而产生混淆。</p> <p>假设在一个零售销售数据仓库中，有产品维度表和销售事实表。产品维度表包含“产品ID”“产品名称”“产品类别”“供应商”等属性；销售事实表包含“销售ID”“产品ID”“销售日期”“销售数量”等信息，通过“产品ID”与产品维度表关联。</p> <p>在产品维度表中，“供应商”这个属性可能会出现空值。比如，部分产品是由公司自主生产，没有外部供应商，在录入数据时，这些产品对应的“供应商”属性就可能为空。</p> <p>当用户进行数据分析时，如果先按“产品类别”这个完全填充的维度属性进行分组，并对“销售数量”进行求和。假设“饮料”类别产品的销售数量总和为1000瓶。</p> <p>然后，用户再按“供应商”这个包含空值的维度属性进行分组并对“销售数量”求和。由于空值在不同数据库中的处理方式不同，有些数据库会直接忽略空值行，有些则可能将空值当作一种特殊的分组来处理。这就导致在不同的处理方式下，得到的销售数量总和结果会不一样。比如，忽略空值行时计算出的总和可能只包含有明确供应商产品的销售数量，与包含空值行计算出的结果有差异。这种差异会让用户对数据的一致性产生怀疑，认为数据不准确，进而可能会向数据管理团队反馈问题 。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>: observation set（观测集）是在数据挖掘场景下涉及的概念。在进行数据挖掘时，需要创建用于分析的数据集合，这个集合就是观测集。</p> <h3 id="其他零售销售维度"><a href="#其他零售销售维度" class="header-anchor">#</a> 其他零售销售维度</h3> <p>Other Retail Sales Dimensions</p> <p><strong>任何</strong>在事实表测量事件存在时取单一值的描述性属性，都适合添加到现有维度中，或者单独成为一个维度。一个维度是否应与事实表相关联，应根据事实表声明的粒度进行二元的是或否的判断。例如，每笔交易可能都会有一个对应的收银员。相应的收银员维度可能会包含一小部分非隐私性的员工属性。与促销维度类似，收银员维度可能也会有一个 “无收银员” 行，用于表示通过自助收银机处理的交易。</p> <p>支付方式的情况则更为复杂。</p> <ul><li>也许商店有严格的规定，每笔交易只接受一种支付方式。这会让作为维度建模人员的你更轻松，因为你可以在销售模式中附加一个简单的支付方式维度，该维度可能包括支付方式描述，以及可能将支付方式分组为现金等价物或信用支付类型。</li> <li>在现实生活中，支付方式往往更为复杂。如果在一笔POS交易中接受多种支付方式，那么在声明的粒度下，支付方式就不会取单一值。与其将声明的粒度更改为不自然的粒度，比如POS交易中每个产品的每种支付方式对应一行，你<strong>可能</strong>会在一个单独的事实表中记录支付方式，其粒度可以是每笔交易一行（这样各种支付方式选项将作为单独的事实出现），或者每笔交易的每种支付方式一行（这将需要一个单独的支付方式维度与每一行相关联）。</li></ul> <h3 id="交易编号的退化维度"><a href="#交易编号的退化维度" class="header-anchor">#</a> 交易编号的退化维度</h3> <p>Degenerate Dimensions for Transaction Numbers</p> <p>零售销售事实表的每一行项目都包含POS交易编号。在操作型的父子数据库中，POS交易编号将是交易头记录the transaction header record[^3.3.6-1]的键，其中包含适用于整个交易的所有信息，如交易日期和商店标识符。然而，在维度模型中，你已经将这些有趣的头信息header information提取到了其他维度中。POS交易编号仍然有用，因为它可以作为分组键the grouping key，将在一次购物篮交易中购买的所有产品组合在一起。它还可能使你能够链接回操作系统。</p> <p>虽然POS交易编号在事实表中看起来像一个维度键，但原本可能属于POS交易维度的描述性项目已经被剥离。<strong>由于得到的维度为空，我们将POS交易编号称为退化维度</strong>（在本书的图中用DD表示）。像POS交易编号这样的自然操作票号，自身存在于sits by itself事实表中，不与维度表进行连接。当事实表的粒度代表单个交易或交易行时，退化维度非常常见，因为退化维度代表了父级的唯一标识符。订单编号、发票编号和提单编号在维度模型中<strong>几乎总是</strong>作为退化维度出现。</p> <p>退化维度通常在事实表的主键中起着不可或缺的作用。在我们的案例研究中，假设购物篮中相同产品的扫描被合并为一个行项目，那么<u>零售销售事实表的主键</u>由退化的POS交易编号和产品键组成。</p> <p>注意：操作交易控制编号，如订单编号、发票编号和提单编号，通常会导致出现空维度，并在事务事实表中表示为退化维度。退化维度<strong>是</strong>一个没有相应维度表的维度键。</p> <p>如果由于某种原因，在创建了所有其他维度后，仍然有一个或多个属性合理地剩余，并且这些属性似乎属于这个头实体this header entity，那么你可以简单地创建一个普通的维度行，并进行普通的连接。然而，这样你就不再有退化维度了。</p> <p>[^3.3.6-1]: 在操作型的父子数据库中，the transaction header record（事务头记录）是包含与整个交易相关的所有有效信息的记录。其中涵盖如交易日期、商店标识符等内容</p> <h2 id="retail-schema-in-action"><a href="#retail-schema-in-action" class="header-anchor">#</a> Retail Schema in Action</h2> <p>设计好零售POS模式后，让我们说明一下<u>它在查询环境中的使用方式</u>。一位业务用户可能对<u>2013年1月波士顿地区门店零食类产品按促销活动分类的每周销售美元金额</u>感兴趣。如图3 - 12所示，你需要在日期维度中对月份和年份进行查询约束，在商店维度中对地区进行约束，在产品维度中对类别进行约束。</p> <p>如果查询工具按周末日期和促销活动对销售美元金额进行求和，SQL查询结果可能如图3 - 13所示。你可以清楚地看到维度模型与相关查询之间的关系。高质量的维度属性<strong>至关重要</strong>，因为它们是查询约束和报告标签的来源。如果你使用功能更强大的BI工具，结果可能会以交叉表 “透视” 报告a cross-tabular “pivoted” report的形式呈现，这可能比SQL语句生成的列数据对业务用户更具吸引力。</p> <h2 id="retail-schema-extensibility"><a href="#retail-schema-extensibility" class="header-anchor">#</a> Retail Schema Extensibility</h2> <p>零售模式<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>的可扩展性</p> <p>让我们将注意力转向扩展初始维度设计。在‘零售销售模式’推出几年后，零售商实施了‘常客计划’。现在，你不再只是知道<u>有一位身份不明的购物者在收银小票上购买了26件商品</u>，而是可以<u>识别出具体的购物者</u>。想象一下，业务用户会对根据众多地理、人口统计、行为和其他区分购物者的特征来分析购物模式多么感兴趣。</p> <p>处理这个新的常客信息相对简单。你<strong>需要</strong>创建一个常客维度表，并在事实表中添加另一个外键。由于你不能要求购物者拿出所有旧的收银小票，用他们新的常客编号标记历史销售交易，所以你<strong>需要</strong>在历史事实表行上用一个默认的购物者维度代理键代替，该代理键对应于 “常客计划实施前” 的维度行。同样，并非每个在杂货店购物的人都有常客卡，所以你还需要在购物者维度中包含一个 “未识别的常客” 行<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>。正如我们之前在促销维度中讨论的，事实表中不能有空的常客键。</p> <p>我们最初的模式能够很好地扩展以适应这个新维度，这在很大程度上是因为POS交易数据最初是在最细粒度级别进行建模的。在该粒度级别添加适用的维度不会改变现有的维度键或事实；所有现有的BI应用程序都可以继续运行，无需任何更改。如果最初将<strong>粒度</strong>声明为每日零售销售额（按日、商店、产品和促销汇总的交易），而不是交易行细节，那么你就无法整合常客维度。过早的汇总或聚合本质上会限制你添加补充维度的能力，因为额外的维度通常不适用于更高的粒度。</p> <p>维度模型具有可预测的对称性the predictable symmetry ，使其能够吸收源数据和 / 或建模假设中的一些重大变化，而不会使现有的BI应用程序失效，包括：</p> <ul><li><strong>新的维度属性</strong>：如果你发现了维度的新文本描述符，可以将这些属性作为新列添加。所有现有应用程序都不会注意到新属性，并继续正常运行。如果新属性仅在特定时间点之后可用，那么在旧的维度行中应填充 “Not Available”（不可用）或其等效值。需要注意的是，如果业务用户想要跟踪这个新识别属性的历史变化，情况会更复杂。在这种情况下，请密切关注第5章中关于缓慢变化维度的内容the slowly changing dimension coverage in Chapter 5<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>。</li> <li><strong>新维度</strong>：正如我们刚刚讨论的，你可以通过添加一个新的外键列，并使用新维度的主键值正确填充它，将一个维度添加到现有的事实表中。</li> <li><strong>新测量事实</strong>：如果有新的测量事实可用，你可以将它们顺利添加到事实表中。
<ul><li>最简单的情况是，新事实与现有事实在同一测量事件中出现the new facts are available in the same measurement event<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>，并且具有相同的粒度。在这种情况下，修改事实表以添加新列，并将值填充到表中。</li> <li>如果新事实仅从某个时间点开始可用，则需要在旧的事实表行中填入空值。</li> <li>当新测量事实自然出现在不同的粒度时，情况会更复杂。如果新事实无法分配或指定到事实表的原始粒度，那么新事实应属于它们自己的事实表，因为在同一个事实表中混合粒度是错误的。</li></ul></li></ul> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a></p> <p>schema 指的是数据仓库中的模式，它定义了数据的组织和结构方式，用于构建维度模型。在零售销售的场景下，涉及到各种维度表（如产品维度表、商店维度表、促销维度表等）和事实表，这些表之间的关系以及表内的列结构等共同构成了零售销售的 schema。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>
假设一家大型连锁超市推出了常客计划。在这个计划推出之前，超市的销售数据中只能记录顾客购买了哪些商品，但无法识别具体顾客身份。例如，在2023年10月1日，一位顾客在001号门店购买了一瓶牛奶和一条面包，销售记录仅包含产品信息、门店信息、交易时间等，没有顾客的身份标识。</p> <p>常客计划推出后，超市为每个参与计划的顾客分配了唯一的常客编号。这时，需要创建一个常客维度表，表中包含常客编号、顾客姓名、联系方式、会员等级等信息。同时，在销售事实表中添加一个外键，用于关联常客维度表。</p> <p>对于历史销售数据，由于无法让顾客提供以往的购物小票来关联新的常客编号，所以会在历史事实表的行中，使用一个默认的常客维度代理键。比如，将“0”作为默认的代理键，它对应着常客维度表中“Prior to Frequent Shopper Program”（常客计划推出前）的维度行。这意味着这些记录是在常客计划实施之前产生的，无法确定具体的常客信息。</p> <p>另外，并非所有来超市购物的顾客都参与了常客计划。例如，在2023年10月5日，一位未参与常客计划的顾客在003号门店购买了一些水果。在这种情况下，为了避免销售事实表中出现空的常客键，需要在常客维度表中添加一个“Frequent Shopper Not Identified”（未识别的常客）行，并为其分配一个代理键，假设是“ - 1”。这样，在销售事实表中，针对这位顾客的购买记录，就可以使用“ - 1”这个代理键来关联常客维度表，确保数据的完整性和一致性。 具体表设计如下：</p> <p>结合文本内容，为呈现常客计划相关数据，需构建常客维度表与调整销售事实表。示例如下：</p> <table><thead><tr><th>常客维度表</th> <th>说明</th></tr></thead> <tbody><tr><td>常客键（PK）</td> <td>代理主键，如1、2、3等顺序分配的整数，用于唯一标识每个常客记录</td></tr> <tr><td>常客编号（NK）</td> <td>超市分配给参与常客计划顾客的唯一编号，类似“FS0001”“FS0002”等</td></tr> <tr><td>顾客姓名</td> <td>顾客真实姓名</td></tr> <tr><td>联系方式</td> <td>顾客的电话号码或电子邮箱等</td></tr> <tr><td>会员等级</td> <td>例如“普通会员”“银卡会员”“金卡会员”等</td></tr> <tr><td>注册日期</td> <td>顾客注册成为常客的日期</td></tr> <tr><td>上次购物日期</td> <td>顾客最近一次购物的日期</td></tr> <tr><td>维度特殊标识</td> <td>包含“Prior to Frequent Shopper Program”和“Frequent Shopper Not Identified”等特殊标识的对应记录，分别用于处理历史数据和未识别常客情况</td></tr> <tr><td>销售事实表（调整后）</td> <td>说明</td></tr> <tr><td>----</td> <td>----</td></tr> <tr><td>销售ID</td> <td>主键，唯一标识每笔销售交易</td></tr> <tr><td>产品键（FK）</td> <td>关联产品维度表，确定销售的产品</td></tr> <tr><td>商店键（FK）</td> <td>关联商店维度表，确定销售发生的商店</td></tr> <tr><td>日期键（FK）</td> <td>关联日期维度表，确定销售日期</td></tr> <tr><td>促销键（FK）</td> <td>关联促销维度表，确定销售时的促销活动</td></tr> <tr><td>常客键（FK）</td> <td>关联常客维度表，若顾客参与常客计划则记录对应常客键；对于历史数据或未识别常客，分别记录对应默认代理键（如“0”或“ - 1” ）</td></tr> <tr><td>销售数量</td> <td>该产品的销售数量</td></tr> <tr><td>销售金额</td> <td>该产品的销售金额</td></tr> <tr><td>其他事实字段</td> <td>如折扣金额、成本金额等</td></tr></tbody></table> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>
“The predictable symmetry”（可预测的对称性）指维度模型在结构和设计上具有规律性和一致性，这使得它面对源数据和建模假设的变化时，能展现出稳定且可预期的适应能力。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>单词coverage理解。这句话中，“coverage” 可理解为 “涵盖内容”“涉及范围” 。如果业务用户想要跟踪新识别属性的历史变化这种情况，就需要密切关注第 5 章中关于缓慢变化维度所涵盖的内容、涉及的处理方法和相关要点等</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>这个翻译的不太好。详细解释这句话的含义</p> <p>在零售销售数据的维度模型里，测量事件可以是一次POS交易。比如在一次POS交易中，原本记录了产品的销售数量、销售额等事实。如果此时新增加了“产品的利润贡献额”这一事实，且它也是在这次POS交易过程中产生并被记录的，那么就属于“the new facts are available in the same measurement event”这种情况。在这种情况下，处理起来相对简单，只需在事实表中添加相应的新列，并将“产品的利润贡献额”的值填充进去即可 。</p> <h2 id="无事实事实表"><a href="#无事实事实表" class="header-anchor">#</a> 无事实事实表</h2> <p>之前的零售销售模式无法回答一个重要问题：哪些产品在促销但‘没有’售出？销售事实表只记录实际售出的SKU。对于未售出的SKU，不会有事实表行记录零销售事实，因为这样会极大地增加事实表的大小。</p> <p>在关系型数据库中，需要一个促销覆盖或事件事实表a promotion coverage or event fact table<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>来回答关于<strong>未发生事件</strong>的问题。</p> <ul><li>在本案例研究中，‘促销覆盖事实表’的键将是日期、产品、商店和促销。这显然与你刚刚设计的‘销售事实表’相似；</li> <li>然而，它们的粒度有很大<strong>不同</strong>。对于促销覆盖事实表，你需要为商店中每天（或者如果零售促销持续一周，则为每周）促销的每个产品加载一行，无论该产品是否售出。</li> <li>这个事实表使你能够看到由促销定义的键之间的关系，而不受其他事件（如实际产品销售）的影响。</li> <li>我们将其称为无事实事实表，因为它没有测量指标；它只是捕获相关键之间的关系，如图3 - 14所示。</li> <li>为了便于计数，你可以在这个例子中包含一个虚拟事实，如促销计数，它始终包含常量值1；这是一种表面上的增强，使BI应用程序能够避免对其中一个外键进行计数。</li></ul> <p>要确定哪些产品在促销但没有售出，需要分两步进行。首先，你需要查询促销无事实事实表，以确定给定日期内促销的产品范围。然后，你需要从POS销售事实表中确定哪些产品售出。我们最初问题的答案就是这两个产品列表之间的差异集。如果你在OLAP立方体中处理数据，回答 “未发生的事情” 这个问题通常会更容易，因为立方体通常会为未发生的行为包含显式单元格。</p> <p>这里的 “coverage” 可以理解为 “覆盖范围” 或 “涵盖情况”，具体是指对促销活动涉及范围的记录和描述。在这种语境下，“promotion coverage fact table”（促销覆盖事实表）用于记录在特定时间（每天或每周）、特定商店中参与促销的产品情况，而不考虑产品是否实际售出，即涵盖了所有参与促销的产品相关信息，强调的是促销活动所涉及的产品范围 。</p> <p>这里应该是这样断句a promotion coverage fact table or a promotion event fact table，promotion coverage fact table和promotion event fact table应该是指的同一个东西。在这段内容中，“coverage”和“event”都与促销活动相关，二者紧密联系但又有区别：</p> <ul><li><strong>联系</strong>：都用于描述促销活动相关信息，“promotion coverage or event fact table”（促销覆盖或事件事实表）这一概念将二者关联，此表用于记录促销活动中产品的相关情况。“coverage”所涉及的促销覆盖范围信息，以及“event”代表的促销活动事件信息，都通过该表的键（日期、产品、商店和促销）来体现，是从不同角度对促销活动在数据记录层面的描述。</li> <li><strong>区别</strong>：“coverage”强调促销活动的覆盖范围，“promotion coverage fact table”记录商店中每天（或每周）参与促销的产品，不论是否售出，重点在于涵盖参与促销的产品，展现促销活动的涉及面；“event”侧重于促销活动本身这一事件，以事件的维度来记录相关信息，更强调事件的发生及与之相关的各种要素组合，“event fact table”记录事件中各要素（日期、产品、商店、促销）之间的关系。此外，“factless fact table”（无事实事实表）主要围绕“coverage”展开，因为它关注的是促销覆盖范围下产品与各维度的关系，本身没有实际测量指标，仅捕捉键之间的关系，而“event”代表的促销活动事件会涉及更多实际发生的情况和指标 。</li></ul> <h2 id="维度和事实表键"><a href="#维度和事实表键" class="header-anchor">#</a> 维度和事实表键</h2> <p>现在已经设计好了模式，我们将<strong>重点关注</strong>维度和事实表的‘主键’，以及其他行标识符 row identifiers。</p> <h3 id="维度表代理键"><a href="#维度表代理键" class="header-anchor">#</a> 维度表代理键</h3> <ul><li>维度表的<strong>唯一</strong>主键应该是代理键，而不是依赖于操作系统标识符（即自然键）。</li> <li>代理键还有许多其他别名：无意义键、整数键、非自然键、人工键和合成键。</li> <li>代理键只是根据需要顺序分配以填充维度的整数。第一个产品行被分配的产品代理键值为1；下一个产品行被分配产品键2；依此类推。实际的代理键值没有业务意义。</li> <li>代理键仅仅用于将维度表与事实表连接起来。<strong>在本书中，以Key后缀命名的列（标识为主键（PK）或外键（FK））都意味着是代理键。</strong></li></ul> <p>建模人员Modelers有时不愿意放弃自然键，因为他们希望基于操作代码浏览事实表，同时避免连接到维度表navigate the fact table based on the operational code while avoiding a join to the dimension table.。他们也不想丢失通常作为自然多部分键a natural multipart key中的一部分的内在信息the embedded intelligence。然而，你<strong>应该</strong>避免依赖智能维度键intelligent dimension keys<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>，因为你所做的任何假设最终都可能无效。同样，查询和数据访问应用程序queries and data access applications不应内置对键的依赖，因为这种逻辑也容易失效。即使自然键看起来稳定且无意义，也不要试图将它们用作维度表的主键。</p> <p>注意：数据仓库中维度表和事实表之间的每一个连接都应该基于无意义的整数代理键。你应该避免使用自然键作为维度表的主键。</p> <p>最初，使用操作自然键实施维度模型可能会更快，但从长远来看，代理键会带来回报。我们有时会将它们比作数据仓库的流感疫苗 —— 就像免疫一样，引入和管理代理键会有一点痛苦，但长期来看好处是巨大的，特别是考虑到大幅减少了返工的风险。以下是几个优点：</p> <ul><li><strong>缓冲数据仓库免受操作变化的影响</strong>Bufer the data warehouse from operational changes：代理键使仓库团队能够控制DW/BI环境，而不会受到用于生成、更新、删除、回收和重用生产代码production codes的操作规则的影响。在许多组织中，历史操作代码（如不活跃的账号或过时的产品代码）在闲置一段时间后会被重新分配。如果账号在12个月不活动后被回收，操作系统不会受到影响，因为它们的业务规则不允许数据长时间闲置。但DW/BI系统可能会保留数据数年。代理键为仓库提供了一种区分同一操作账号不同实例的机制。如果你仅仅依赖操作代码，在数据合并或收购an acquisition or consolidation of data的情况下，你可能还会受到键重叠key overlaps的影响<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>。</li> <li><strong>集成多个源系统</strong>：代理键使数据仓库团队能够集成来自多个操作源系统的数据，即使它们缺乏一致的源键，也可以通过后台交叉引用映射表将多个自然键链接到一个公共代理键。</li> <li><strong>提高性能</strong>：代理键是尽可能小的整数，同时确保它能够轻松适应未来预期的基数（维度中的行数）。通常，操作代码the operational code是冗长的字母数字字符串，甚至是一组字段。较小的代理键意味着更小的事实表、更小的事实表索引，以及每个块输入 - 输出操作中更多的事实表行。通常，一个4字节的整数足以处理大多数维度。一个4字节的整数是一个整数，而不是四个十进制数字。它有32位，因此可以处理大约20亿个正值（$2^{32}$)）或40亿个正负值（-2^32到 +2^32）。这对于几乎任何维度来说都足够了。请记住，如果你有一个包含10亿行数据的大型事实表，那么事实表每行中的每个字节都会增加一GB的存储量。</li> <li><strong>处理空值或未知条件</strong>：如前所述，特殊的代理键值用于记录可能没有操作代码的维度条件，例如“无促销”条件或匿名客户。即使缺乏操作编码，你也可以分配一个代理键来识别这些情况。同样，事实表中有时会有尚未确定的日期。对于“待确定日期”或“不适用日期”，没有SQL日期类型值。</li> <li><strong>支持维度属性变更跟踪</strong>：处理‘维度属性变更’的主要技术之一依赖于代理键来处理单个自然键的多个配置文件<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>。这实际上是使用代理键的<strong>最重要</strong>原因之一，我们将在第5章中详细描述。通过简单地将自然键与时间戳连接在一起创建的‘伪代理键’是有风险的。你需要避免维度表和事实表之间的‘多次’连接，有时称为“双管连接” double-barreled joins，因为它们会对性能和易用性产生不利影响。</li></ul> <p>当然，分配和管理代理键需要付出一些努力，但它并不像许多人想象的那么困难。你需要在ETL系统中建立并维护一个交叉引用表a cross-reference table，用于在每个事实表和维度表行上替换适当的代理键。我们将在第19章“ETL子系统和技术”中详细介绍‘管理’代理键的过程。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a></p> <p>“intelligent dimension keys”指具有业务含义、结构复杂且包含特定信息的维度表自然键，其部分或整体能体现业务相关特性。以产品编码为例，假设某产品编码“P001 - A - 01”，“P001”代表产品线，“A”代表产地，“01”代表规格。这种编码结构让使用者能直接获取产品相关信息，看似方便。但实际上，它存在诸多问题，所以不适合作为维度表主键。 - <strong>业务规则变化风险</strong>：业务规则改变或发生组织合并时，自然键可能变动。如公司收购新品牌，产品编码规则可能调整，依赖原编码的查询和数据处理逻辑会失效。 - <strong>数据集成问题</strong>：集成多个源系统数据时，不同系统自然键可能不同。若直接使用自然键，会因缺乏一致性导致数据整合困难，难以统一管理和分析数据。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a></p> <p>“an acquisition or consolidation of data”指数据的获取或整合，通常发生在企业合并、收购其他公司，或者整合内部不同部门、系统的数据时。在此过程中，会涉及到将多个数据源的数据合并到一个数据环境中 。 “key overlaps”即键重叠，是指在数据整合过程中，不同数据源使用了相同的键值来标识不同的实体。比如，两个公司合并后进行数据整合，原A公司和B公司都使用“001”作为某个客户的ID，但这两个“001”对应的是不同客户。如果仅依靠这些相同的操作代码（自然键），在数据合并时就会出现混淆，导致数据错误，而代理键可以有效避免这种键重叠带来的问题 。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a></p> <p>“the multiple profiles for a single natural key” 指的是在维度属性发生变化时，同一个自然键可能对应多种不同的属性状态或版本。自然键是由业务系统分配和使用的键，例如产品的编码、客户的身份证号码等。在业务发展过程中，相关维度属性会改变，如产品的类别可能调整，客户的地址可能变更。例如，某产品的自然键是 “P001”，其最初的类别属性是 “零食”，后来调整为 “休闲食品”。使用代理键时，可在属性变化时分配新的代理键，从而记录下该产品在不同阶段的不同属性状态，方便进行历史数据的追踪和分析 。</p> <h3 id="维度自然键和持久超自然键"><a href="#维度自然键和持久超自然键" class="header-anchor">#</a> 维度自然键和持久超自然键</h3> <ul><li>与代理键一样，操作源系统分配和使用的自然键也有其他名称，如业务键、生产键和操作键。</li> <li>在本书的图中，它们用NK符号标识。</li> <li>自然键<strong>通常</strong>在维度表中建模为一个属性。</li> <li>如果自然键来自多个源，你可能会使用一个字符数据类型a character data type，并在前面加上源代码，如“SAP|43251”或“CRM|6539152” 。</li> <li>如果同一实体在两个操作源系统中都有表示，那么你可能会在维度中对应两个源分别有两个自然键属性。</li> <li>操作自然键通常由有意义的组成部分构成，比如产品的业务线或原产国；这些组件components应该被拆分并作为单独的属性提供。</li></ul> <p>在<u>具有属性变更跟踪的维度表</u>中，拥有<u>一个能够在维度实体的属性变更过程中唯一且可靠地识别它的标识符</u>非常重要。虽然操作自然键似乎符合这个要求，但有时由于意外的业务规则（如组织合并）或为了处理重复条目或来自多个源的数据集成，自然键会发生变化。如果维度的自然键不能随着时间的推移得到‘绝对保护和保留’，ETL系统就需要分配永久的持久标识符，也称为超自然键。持久的超自然键由DW/BI系统控制，在系统的整个生命周期内保持不变。与维度代理键一样，它是一个简单的整数，按顺序分配。与前面讨论的自然键一样，持久超自然键作为维度属性处理；它不是维度表代理主键的替代品。第19章还将讨论ETL系统对这些‘持久标识符’的管理责任。</p> <h3 id="退化维度代理键"><a href="#退化维度代理键" class="header-anchor">#</a> 退化维度代理键</h3> <p>虽然<strong>通常</strong>不会为退化维度分配代理键，但需要根据具体情况评估是否需要。如果交易控制编号在不同位置<u>不唯一或被重复使用</u>，就需要代理键。例如，零售商的POS系统可能不会在各个商店之间分配唯一的交易编号。当编号达到最大值时，系统可能会重置为零并重新使用以前的控制编号。此外，交易控制编号可能是一个占用24字节的字母数字列。最后，根据BI工具的功能，你可能需要分配一个代理键（并创建一个相关的维度表）以便按交易编号进行交叉钻取。显然，以这种方式建模并带有相应维度表的控制编号维度<strong>不再是</strong>退化维度。</p> <h3 id="日期维度智能键"><a href="#日期维度智能键" class="header-anchor">#</a> 日期维度智能键</h3> <p>如前所述，日期维度具有<strong>独特</strong>的特征和要求。日历日期是固定且预先确定的；你永远不必担心删除日期或处理日历上意外的新日期。由于其可预测性，你可以为日期维度使用更具智能的键use a more intelligent key for the date dimension。</p> <ul><li>如果一个顺序整数用作日期维度的主键，它应该按时间顺序分配。换句话说，第一年的1月1日将被分配代理键值1，1月2日将被分配代理键2，2月1日将被分配代理键32，依此类推。</li> <li>更常见的是，日期维度的主键是一个有意义的整数，格式为yyyymmdd。
<ul><li>这个yyyymmdd键并<strong>不是</strong>为了让业务用户及其BI应用程序绕过日期维度直接查询事实表而设计的智能键。在‘事实表的yyyymmdd键’上进行过滤会对可用性和性能产生不利影响。</li> <li>对日历属性的过滤和分组应该在‘维度表’中进行，而不是在‘BI应用程序代码’中。</li> <li>然而，yyyymmdd键对于对事实表进行‘分区’很有用。分区可以将一个表在底层分割成较小的表。基于日期对大型事实表进行分区是有效的，因为它允许优雅地删除旧数据，并在当前分区中加载和索引新数据，而不会影响事实表的其他部分。它减少了加载、备份、归档和查询响应所需的时间。如果日期键是一个有序整数，那么以编程方式更新和维护分区就很简单：年份按1递增，直到达到所需的年数，月份按1递增，直到12，依此类推。使用智能的yyyymmdd键既具有代理键的优点，又便于分区管理。</li></ul></li></ul> <p>虽然yyyymmdd整数是日期维度键最常见的方法，但一些关系数据库优化器<strong>更喜欢</strong>使用‘真正的日期类型列’进行分区。</p> <ul><li>在这些情况下，优化器知道3月1日到4月1日之间有31个值，而不是20130301和20130401之间看似的100个值。</li> <li>同样，它知道12月1日到1月1日之间有31个值，而不是20121201和20130101之间的8900个整数值。</li> <li>这种智能可以影响优化器选择的查询策略，并进一步减少查询时间。如果优化器包含日期类型智能，则应考虑使用它作为日期键。</li> <li>如果使用日期类型键的唯一理由是为了简化数据库管理员的管理工作，那么你可以不用那么坚持。</li></ul> <p>对于更智能的日期键，无论是按时间顺序分配的，还是更有意义的yyyymmdd整数或日期类型列，你都需要为<u>事实行最初加载时日期未知的情况</u>保留一个特殊的日期键值<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>: 正常情况下，2023 年 10 月 15 日对应的键值为<code>20231015</code> 。但在数据加载时，如果某条销售记录的日期未知，就需要预留一个特殊的日期键值。比如，规定<code>99999999</code>代表日期未知。当有一笔交易无法确定具体日期时，在事实表中该交易对应的日期键就使用<code>99999999</code> 。这样，在后续数据分析和处理过程中，系统就能识别出这些日期未知的记录，并且可以对它们进行特殊处理或标记，而不会与正常的日期键值产生混淆。</p> <h3 id="事实表代理键"><a href="#事实表代理键" class="header-anchor">#</a> 事实表代理键</h3> <p>虽然我们<strong>坚决主张</strong>在维度表中使用代理键，但对事实表的代理键要求则<strong>没那么严格</strong>。事实表代理键通常仅对后台ETL处理有意义。如前所述，事实表的主键通常由表的外键和 / 或退化维度的一个子集组成。然而，事实表的单列代理键在后台有一些有趣的优点。</p> <p>与维度代理键类似，事实表代理键是一个简单的整数，不包含任何业务内容，在生成事实表行时按顺序分配。虽然事实表代理键不太可能带来查询性能优势，但它确实有以下好处：</p> <ul><li><strong>立即唯一标识</strong>：单个事实表行可以通过键立即标识。在ETL处理过程中，无需遍历多个维度即可识别特定的行。</li> <li><strong>回滚或恢复批量加载</strong>：如果正在加载大量按顺序分配代理键的行，并且加载过程在完成前停止，数据库管理员可以通过查找表中的最大键来准确确定加载过程停止的位置。数据库管理员可以通过指定刚加载的键范围来回滚整个加载过程，或者也许可以从正确的位置恢复加载。</li> <li><strong>用‘插入+删除’替换更新</strong>：事实表代理键成为事实表真正的物理键。至少就关系数据库管理系统而言，事实表的键不再由一组维度外键决定。因此，用插入后再删除的操作替换事实表更新操作成为可能。第一步是将新行插入数据库，其所有业务外键与要替换的行相同。现在这是可行的，因为键的强制约束仅取决于代理键，而替换行有一个新的代理键。然后第二步删除原始行，从而完成更新。对于大量的更新操作，这种顺序比一组真正的更新操作<strong>更高效</strong>。插入操作可以按照前面所述的方式进行回滚或恢复。这些插入操作不需要使用完整的事务机制来保护。然后，在插入操作完成后，可以安全地执行最后的删除步骤。</li> <li><strong>在父子模式 a parent/child schema中用作父键</strong>：在某些情况下，一个事实表中的行是较低粒度事实表中行的父行，父表中的事实表代理键也会在子表中显示。
<ul><li>在这种情况下使用事实表代理键而不是自然父键的理由，与在维度表中使用代理键的理由类似。自然键复杂且不可预测，而代理键是干净的整数，由ETL系统分配，而不是源系统。</li> <li>当然，除了包含‘父事实表的代理键’之外，较低粒度的事实表还应该包含‘父表的维度外键’，这样子事实就可以在不遍历父事实表代理键的情况下进行切片和切块分析。</li> <li>正如我们将在第4章“库存”中讨论的，你<strong>永远不应该</strong>直接将事实表与其他事实表连接。</li></ul></li></ul> <h2 id="抵制规范化冲动"><a href="#抵制规范化冲动" class="header-anchor">#</a> 抵制规范化冲动</h2> <p>在本节中，让我们直接面对一些来自规范化背景的建模人员容易产生的自然冲动。我们一直在有意打破一些传统的建模规则，因为我们专注于通过易用性和性能来实现价值，而不是事务处理效率。</p> <h3 id="具有规范化维度的雪花模式"><a href="#具有规范化维度的雪花模式" class="header-anchor">#</a> 具有规范化维度的雪花模式</h3> <p>扁平的、非规范化的维度表中存在重复的文本值，这让来自操作型数据库领域的数据建模人员感到不安。让我们回顾一下案例研究中的产品维度表。300,000种产品归属于50个不同的部门。</p> <ul><li>**他们认为这种设计可以减少冗余、从而节省空间：**具有规范化思维的建模人员不想在产品维度表中冗余存储20字节的部门描述，而是希望存储一个2字节的部门代码，然后创建一个新的部门维度来解码部门描述。实际上，他们会更倾向于将原始设计中的所有描述符都规范化到单独的维度表中。他们认为这种设计可以节省空间，因为300,000行的维度表只包含代码，而不是冗长的描述符。</li> <li>**此外，一些建模人员认为更规范化的维度表更容易维护：**如果部门描述发生变化，他们只需要在部门维度中更新一次，而不是在原始产品维度表中的6,000个重复项中进行更新。维护工作通常由规范化原则来处理，但所有这些都在数据加载到展示区的维度模式之前，在ETL系统中完成。</li></ul> <p>维度表规范化被称为雪花化。冗余属性从扁平的、非规范化的维度表中移除，并放置在单独的规范化维度表中。图3 - 15展示了产品维度部分雪花化到第三范式的情况。图3 - 15和图3 - 8之间的对比令人震惊。即使在我们这个简单的示例中，大量的雪花化表也让人应接不暇。想象一下，如果模式中的所有层次结构都进行规范化，对图3 - 12会产生什么影响。</p> <p>雪花化是维度模型的一种合法扩展，然而，考虑到易用性和性能这两个主要设计驱动因素 the two primary design drivers，我们鼓励你<strong>抵制</strong>雪花化的冲动。</p> <ul><li><p>大量的雪花化表会使展示变得更加复杂。业务用户不可避免地会在这种复杂性中挣扎；而简单性是维度模型的主要目标之一。</p></li> <li><p>大多数数据库优化器也会在雪花模式的复杂性面前陷入困境。大量的表和连接通常会导致查询性能下降。由此产生的连接规范的复杂性增加了优化器选择不佳策略的可能性。</p></li> <li><p>雪花化维度表节省的少量磁盘空间微不足道。如果你用一个2字节的代码替换300,000行产品维度表中的20字节部门描述，你将节省5.4MB（300,000×18字节）；与此同时，你可能有一个10GB的事实表！维度表几乎总是比事实表小得多。为了节省磁盘空间而对维度表进行规范化通常是浪费时间。</p></li> <li><p>雪花化会对用户浏览维度的能力产生负面影响。浏览通常涉及约束一个或多个维度属性，并查看在这些约束下另一个属性的不同值。浏览可以帮助用户理解维度属性值之间的关系。</p></li> <li><p>显然，如果您只想要一个类别描述列表，雪花化的产品维度表会有很好的响应。然而，如果你想查看一个类别中的所有品牌，你需要遍历品牌和类别维度。如果你还想列出一个类别中每个品牌的包装类型，你将需要遍历更多的表。执行这些看似简单的查询所需的SQL语句很复杂，而且你甚至还没有涉及其他维度或事实表。</p></li> <li><p>最后，雪花化破坏了位图索引的使用。位图索引在对低基数列（如产品维度表中的类别和部门属性）进行索引时非常有用。它们可以大大加快对单个列的查询或约束的性能。雪花化不可避免地会干扰你利用这种性能调优技术的能力。</p></li></ul> <p>注意：固定深度的层次结构应该在维度表中扁平化。规范化的雪花化维度表会妨碍跨属性浏览，并禁止使用位图索引。通过规范化维度表节省的磁盘空间通常不到整个模式所需总磁盘空间的1%。为了性能和易用性的优势，你应该有意识地牺牲维度表的空间。</p> <p>在这些情况可以考虑雪花模式：</p> <ul><li>一些数据库供应商声称他们的平台有能力查询完全规范化的维度模型而不会有性能损失。如果你可以在不物理非规范化维度表的情况下获得令人满意的性能，那当然很好。然而，你仍然需要实现一个具有非规范化维度的逻辑维度模型，以便向业务用户及其BI应用程序展示一个易于理解的模式。</li> <li>过去，一些BI工具表示更喜欢雪花模式；为了满足BI工具的特殊要求而进行雪花化是<strong>可以接受</strong>的。同样，如果所有数据都是通过OLAP立方体提供给业务用户的（在这种情况下，雪花化维度用于填充立方体，但对用户不可见），那么雪花化也是<strong>可以接受</strong>的。然而，在这些情况下，你<strong>需要考虑</strong>对使用其他BI工具的用户的影响，以及未来迁移到其他工具的灵活性。</li></ul> <h3 id="外扩维度"><a href="#外扩维度" class="header-anchor">#</a> 外扩维度</h3> <p>Outriggers</p> <p>虽然我们通常不建议进行雪花化，但在某些情况下，构建一个外扩维度是可以接受的。外扩维度连接到事实表直接关联的维度上，如图3 - 16所示。</p> <ul><li>在这个例子中，“隔了一层” 的外扩维度the “once removed” outrigge<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>是从‘主维度’中雪花化出来的日期维度。</li> <li>外扩日期属性被描述性地、唯一地标记，以区别于与业务流程相关的其他日期。</li> <li><strong>只有</strong>当业务希望按非标准日历属性（如财年期间、工作日指示符或节假日期间）对这个日期进行过滤和分组时，将主维度表的日期属性外扩才有意义。否则，你可以将‘日期属性’视为‘产品维度中的标准日期类型列’。</li> <li>如果使用日期外扩维度，要注意外扩日期应在标准日期维度表存储的范围内。</li></ul> <p>在本书后面的章节中，你会遇到更多外扩维度的例子，比如第8章“客户关系管理”中对客户县级人口统计属性的处理。</p> <p>虽然外扩维度可以节省空间，并确保相同的属性被一致引用，但也有缺点。</p> <ul><li>外扩维度会引入更多的连接，这可能会对性能产生负面影响。更</li> <li>重要的是，外扩维度会影响业务用户对模型的理解，并妨碍他们在单个维度中浏览属性的能力。</li></ul> <p>警告：尽管外扩维度是可以接受的，但考虑到其潜在的负面影响，维度模型不应充斥着外扩维度。外扩维度<strong>应该是例外</strong>情况，而不是常规做法。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a></p> <p>在“the ‘once removed’ outrigger”这个表述中，“once removed”表示“隔了一层的；间接的”。这里是指外伸维度（outrigger）与事实表之间是通过主维度间接关联的，并非直接与事实表相连，就好像是从事实表的直接关联维度（主维度）“隔了一层”延伸出来的，所以用“once removed”来形容这种关系。</p> <h3 id="维度过多的蜈蚣型事实表"><a href="#维度过多的蜈蚣型事实表" class="header-anchor">#</a> 维度过多的蜈蚣型事实表</h3> <p>维度模式中的事实表自然是高度规范化且紧凑的。由于维度之间互不相关，所以无法进一步规范化事实表中键之间极其复杂的多对多关系。每家商店每天都营业。迟早，几乎每种产品都会在我们的大多数或所有商店中进行促销销售。</p> <p>有趣的是，一些建模人员虽然对非规范化的维度表感到不安，但却倾向于对事实表进行非规范化。</p> <ul><li>他们无法控制地想要规范化维度层次结构，但又知道雪花化是极不推荐的，所以规范化后的表最终与事实表连接在一起。</li> <li>他们不在事实表中使用‘单个产品外键’，而是包含产品层次结构中经常分析的元素的‘外键’（不止一个），如品牌、类别和部门。同样，日期键突然变成了一系列连接到单独的周、月、季度和年维度表的键。</li> <li>不知不觉中，你原本紧凑的事实表变成了一个难以处理的庞然大物，连接到了几十个维度表。我们亲切地将这些设计称为蜈蚣型事实表，因为它们看起来几乎有100条“腿”，如图3 - 17所示。</li></ul> <p>即使事实表格式紧凑，但它仍然是维度模型中的庞然大物。设计一个维度过多的事实表会显著增加事实表的磁盘空间需求。虽然非规范化的维度表会消耗额外的空间，但事实表的空间消耗<strong>更值得关注</strong>，因为它是规模上大得多的表。在蜈蚣型事实表的例子中，无法有效地对庞大的多部分键进行索引。大量的连接对可用性和查询性能都是个问题。</p> <p>大多数业务流程可以用事实表中少于20个维度来表示。如果一个设计有25个或更多的维度，你<strong>应该</strong>寻找方法将相关的维度合并为一个维度。完全相关的属性（如层次结构的各个级别）以及具有合理统计相关性的属性，应该属于同一个维度。<strong>当合并后的新单个维度明显小于单独维度的笛卡尔积时，合并维度是个不错的决定。</strong></p> <p>注意：维度数量过多通常表明有几个维度并非完全独立，应该合并为一个维度。将‘单个层次结构的元素element’<a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>表示为‘事实表中的单独维度’是维度建模的一个错误。</p> <p>列式数据库的发展可能会减少与‘宽蜈蚣型事实表设计’相关的查询和存储成本。列式数据库不是存储每个表行，而是将每个表列作为一个连续的对象存储，并对其进行大量索引以方便访问。即使底层物理存储是按列进行的，但在查询层面，表看起来仍然是由熟悉的行组成。但是在查询时，只有指定的列会从磁盘中检索，而不是像在更传统的行式关系数据库中那样检索整行。列式数据库对上述蜈蚣型事实表的容忍度要高得多；然而，浏览层次相关维度属性的能力可能会受到影响。</p> <p><a href="%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%98%E5%94%AF%E4%B8%80%E9%94%AE%E2%80%99%EF%BC%9F">^</a>:“element” 指的是单个层次结构中的各个组成部分或元素。例如，在一个组织架构的层次结构中，可能有部门、团队、员工等元素；在地理层次结构中，可能有国家、省 / 州、城市等元素。这里是说，不应该把属于同一个层次结构的这些元素错误地当作事实表中的独立维度来表示，而应该将它们组合到一个维度中。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>本章是你首次接触维度模型的设计。</p> <ul><li><strong>无论</strong>处于哪个行业，我们都强烈推荐采用四步流程来处理维度模型设计。</li> <li>请记住，清晰地声明与维度模式相关的粒度尤为重要。用原子数据填充事实表可提供最大的灵活性，因为这些数据可以 “以各种方式” 进行汇总。一旦事实表被限制为更聚合的信息，当汇总假设被证明无效时，你就会遇到阻碍。</li> <li>此外，用‘详尽、丰富的描述性属性’填充维度表对于分析过滤和标记至关重要。</li></ul> <p>在下一章中，我们将继续以零售行业为例，讨论处理组织内第二个业务流程的技术，确保你之前的工作成果得到利用，同时避免出现数据孤岛stovepipes。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blankornotes/ch2.html" class="prev">
        第二章
      </a></span> <span class="next"><a href="/blankornotes/ch6.html">
        第六章
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blankornotes/assets/js/app.c947165e.js" defer></script><script src="/blankornotes/assets/js/2.a76d4e78.js" defer></script><script src="/blankornotes/assets/js/1.2ec8c7d7.js" defer></script><script src="/blankornotes/assets/js/25.0618aee1.js" defer></script>
  </body>
</html>
