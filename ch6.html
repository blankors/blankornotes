<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>6 订单管理 | 数据仓库工具箱第三版笔记</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="The Data Warehouse Toolkit 3rd Edition">
    
    <link rel="preload" href="/blankornotes/assets/css/0.styles.372fc7a5.css" as="style"><link rel="preload" href="/blankornotes/assets/js/app.c1ab9062.js" as="script"><link rel="preload" href="/blankornotes/assets/js/2.a76d4e78.js" as="script"><link rel="preload" href="/blankornotes/assets/js/1.2ec8c7d7.js" as="script"><link rel="preload" href="/blankornotes/assets/js/27.58cf19bd.js" as="script"><link rel="prefetch" href="/blankornotes/assets/js/10.4c178469.js"><link rel="prefetch" href="/blankornotes/assets/js/11.31060eb5.js"><link rel="prefetch" href="/blankornotes/assets/js/12.279f272d.js"><link rel="prefetch" href="/blankornotes/assets/js/13.10227dfa.js"><link rel="prefetch" href="/blankornotes/assets/js/14.fe714d02.js"><link rel="prefetch" href="/blankornotes/assets/js/15.f53ca535.js"><link rel="prefetch" href="/blankornotes/assets/js/16.d3d5bdeb.js"><link rel="prefetch" href="/blankornotes/assets/js/17.4ef2ea13.js"><link rel="prefetch" href="/blankornotes/assets/js/18.37f5f491.js"><link rel="prefetch" href="/blankornotes/assets/js/19.b774cdca.js"><link rel="prefetch" href="/blankornotes/assets/js/20.5d9c4a68.js"><link rel="prefetch" href="/blankornotes/assets/js/21.47844c93.js"><link rel="prefetch" href="/blankornotes/assets/js/22.06fabd8a.js"><link rel="prefetch" href="/blankornotes/assets/js/23.ff8945e2.js"><link rel="prefetch" href="/blankornotes/assets/js/24.5f4024fd.js"><link rel="prefetch" href="/blankornotes/assets/js/25.61b3ccf4.js"><link rel="prefetch" href="/blankornotes/assets/js/26.685c9a85.js"><link rel="prefetch" href="/blankornotes/assets/js/3.fb6a4e15.js"><link rel="prefetch" href="/blankornotes/assets/js/4.e9f08a68.js"><link rel="prefetch" href="/blankornotes/assets/js/5.3ffe72e2.js"><link rel="prefetch" href="/blankornotes/assets/js/6.8910dfd2.js"><link rel="prefetch" href="/blankornotes/assets/js/7.d094995e.js"><link rel="prefetch" href="/blankornotes/assets/js/vendors~docsearch.06f5d163.js">
    <link rel="stylesheet" href="/blankornotes/assets/css/0.styles.372fc7a5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blankornotes/" class="home-link router-link-active"><!----> <span class="site-name">数据仓库工具箱第三版笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blankornotes/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="blankor的博客" class="dropdown-title"><span class="title">blankor的博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="blankor的博客" class="mobile-dropdown-title"><span class="title">blankor的博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/u012928365" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blankornotes/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="blankor的博客" class="dropdown-title"><span class="title">blankor的博客</span> <span class="arrow down"></span></button> <button type="button" aria-label="blankor的博客" class="mobile-dropdown-title"><span class="title">blankor的博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/u012928365" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blankornotes/" aria-current="page" class="sidebar-link">阅读方式</a></li><li><a href="/blankornotes/ch1.html" class="sidebar-link">第一章</a></li><li><a href="/blankornotes/ch2.html" class="sidebar-link">第二章</a></li><li><a href="/blankornotes/ch3.html" class="sidebar-link">第三章</a></li><li><a href="/blankornotes/ch6.html" aria-current="page" class="active sidebar-link">第六章</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blankornotes/ch6.html#order-management-bus-matrix订单管理总线矩阵" class="sidebar-link">Order Management Bus Matrix订单管理总线矩阵</a></li><li class="sidebar-sub-header"><a href="/blankornotes/ch6.html#order-transactions订单交易" class="sidebar-link">Order Transactions订单交易</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_6-订单管理"><a href="#_6-订单管理" class="header-anchor">#</a> 6 订单管理</h1> <p>订单管理包括几个<strong>关键的业务流程</strong>，包括订单、发货和发票处理。这些流程会产生一些指标，例如销售量和发票收入，这些指标对于任何向其他组织销售产品或服务的组织来说都是关键绩效指标。事实上，这些基础指标如此重要，以至于 DW/BI 团队经常首先处理订单管理流程中的一个。显然，本案例研究中的主题超越了行业界限transcend industry boundaries。在本章中，我们将探讨几个不同的订单管理事务，包括在多维建模这些事务时遇到的常见特征和复杂性。我们将进一步发展累积快照的概念，以分析从初始订单到发票的订单履行管道。第 6章讨论了以下概念：</p> <ul><li>订单管理流程order management processes的总线矩阵片段Bus matrix snippet</li></ul> <p>如前几章所述，总线矩阵与组织的价值链orga-nization's value chain密切相关。在本章中，我们将重点关注矩阵中的订单和发票行。我们还将描述一个累积快照事实表accumulating snapshot fact table，以评估整个订单履行过程的多个阶段的绩效。</p> <h2 id="order-management-bus-matrix订单管理总线矩阵"><a href="#order-management-bus-matrix订单管理总线矩阵" class="header-anchor">#</a> Order Management Bus Matrix订单管理总线矩阵</h2> <h2 id="order-transactions订单交易"><a href="#order-transactions订单交易" class="header-anchor">#</a> Order Transactions订单交易</h2> <p>订单事务事实表的自然粒度natural granularity是每条订单上的每个行项目为一行。与订单业务流程相关联的维是订单日期、请求发货日期、产品、客户、销售代表和交易。事实包括订单数量和扩展的订单行毛额、折扣和净额（等于毛额减去折扣）美元金额。生成的模式将类似于图6-2。</p> <h3 id="fact-normalization事实正常化"><a href="#fact-normalization事实正常化" class="header-anchor">#</a> Fact Normalization事实正常化</h3> <p>与将事实表存储在图 6-2 中相比，一些设计人员希望进一步规范化事实表，以便为每条订单行创建一个<u>单一的、通用的事实</u>以及一个<u>用于标识度量类型的维度</u>。在这种情况下，<strong>事实表粒度为</strong>每条订单行的每种度量一个事实行one row per measurement per order line，而不是更自然地more natural把每条订单行事件作为一个事实行one row per order
line event。度量类型维度measurement type dimension将指示该事实是毛订单金额、订单折扣金额还是其他度量。当事实集非常长，但给定事实行稀疏且事实之间没有计算时，此技术可能具有意义。您可以使用此技术来处理manufacturing quality test data[^6.2.1-1]制造质量测试数据，其中事实因所执行的测试而异。然而，您通常应该<strong>抵制</strong><u>以这种方式对事实表进行normalize[^6.2.1-2]规范化</u>的冲动。事实通常不会稀疏地填充到行中。在订单事务模式中，如果对事实进行规范化，您将把事实表中的行数乘以事实类型的数量。例如，假设您从 1000 万行订单行事实表开始，每行具有 6 个键和 4 个事实。如果对事实行进行规范化，您将得到 4000 万行事实，每行具有 7 个键和 1 个事实。此外，如果在事实之间执行任何算术函数（例如折扣金额占订单总金额的百分比），那么如果事实位于关系星型模式的同一行中，则要容易得多，因为 SQL 使得在不同行的事实之间执行ratio比率或difference差异非常困难。</p> <p><font style="color:#DF2A3F;">在第 14 章：医疗保健</font>中，我们将探讨测量类型维度measurement type dimension更合理的情况。如果支持商业智能（BI）应用程序的主要平台是一个联机分析处理（OLAP）立方体，那么这种模式也更为合适；该cube立方体能够进行沿任意维度对其进行分割的计算，无论这个维度是日期、产品、客户还是度量类型。</p> <p>[^6.2.1-1]: “manufacturing quality test data” 指的是在制造业中，为了评估和确保产品质量而进行的各种测试所产生的数据。</p> <p>[^6.2.1-2]: “normalize” 意思是 “规范化；使标准化” （机翻翻译为了正则化），在数据处理和数据库设计语境下，“fact normalization” 即事实规范化，指调整事实表结构，让数据更规范、有序，减少冗余，提升存储效率和数据处理性能。在 &quot;Fact Normalization&quot; 这一节，是指将事实表进一步规范，把多个事实整合到一个通用事实字段，并添加一个维度来识别度量类型。例如将订单事务事实表中不同类型的金额事实（如订单总金额、订单折扣金额等）进行规范化处理，使每行只包含一个事实和对应的度量类型标识。在此处之前未明确提到 “normalize” 相关内容，但在维度建模的概念中，与之相关的概念是规范化和反规范化。在第 1 章 “Data Warehousing, Business Intelligence, and Dimensional Modeling Primer”（数据仓库、商业智能和维度建模入门）提到，第三范式（3NF）模型通过规范化来消除数据冗余，将数据划分到多个离散实体表中；而维度建模通常采用反规范化的方式，以提升查询性能和用户理解度。如在维度表设计时，会将固定深度的多对一层次结构进行扁平化处理，避免像规范化设计那样创建过多的关联表，这与 “normalize” 的概念相关联，从侧面体现了维度建模与传统规范化设计的差异 。在第 3 章 “Retail Sales”（零售销售）中，也有类似相关内容，讨论雪花模式时提到，一些习惯于规范化设计的建模人员想对维度表进行规范化处理（类似 “normalize” 的操作），将重复的文本值分离到单独的表中，但这种做法在维度建模中可能会带来一些问题，如增加查询复杂度、降低性能等，进一步体现了维度建模中对数据结构处理与传统规范化思路的不同。</p> <h3 id="dimension-role-playing维度角色扮演"><a href="#dimension-role-playing维度角色扮演" class="header-anchor">#</a> Dimension Role Playing维度角色扮演</h3> <p>到目前为止，你知道每个事实表中都包含一个日期维，因为你总是在查看<u>随着时间的推移而发生的绩效performance over time</u>。在事务事实表中，主日期列是事务日期，例如订单日期。有时，您会发现与每个事务相关的其他日期，例如订单的请求装运日期。每个日期都应该是事实表中的外键，如图6-3所示。但是，您不能简单地将这两个外键连接到相同的日期维表。SQL将这种双向同时连接解释为要求两个日期相同，这不太可能。</p> <p>即使你不能literally join to a single date dimension table真正地将数据与单个日期维度表进行连接操作，但你仍然可以构建并管理一个单一的物理日期维度表。然后，通过使用视图或别名，你可以创建两个独立日期维的假象（并不是实际上的两个表）。请注意在每个视图或别名中唯一标记列。例如，订单月份属性应唯一标记，以将其与请求的装运月份区分开来。如果你不建立唯一的列名，当两者都被拖放到报表中时，你将无法区分列。正如我们在第三章“零售销售”中简要描述的，我们将定义<u>订单日期和requested order date请求的订单日期视图</u>如下：</p> <p>或者，SQL支持别名的概念。许多 BI 工具也在其语义层中支持别名。但是，如果组织中同时使用多个BI 工具和基于 SQL 的直接访问，我们<strong>建议不要</strong>使用此方法。</p> <p>无论采用何种实现方法，您现在有两个独特的逻辑日期维，可以像独立维一样使用，并且具有完全无关的约束。这被称为角色扮演，因为日期维在单个事实表中同时扮演不同的角色。您将在本书的各个地方看到有关维角色扮演的更多示例。</p> <p>NOTE 在多维模型中，**当一个维度在同一个事实表中同时出现几次时，就会发生角色扮演。**底层维度可能以单个物理表的形式存在，但每个角色都应作为单独标记的视图呈现给 BI 工具。</p> <p>值得注意的是，一些OLAP products联机分析处理产品不支持同一维度的多个角色；在这种情况下，您需要为两个角色创建两个单独的维度。此外，一些支持多个角色的联机分析处理产品不支持为每个角色重命名属性。最后，联机分析处理环境可能充斥着大量单独的维度，这些维度在关系星型模式中被简单地作为角色对待。为了处理多个日期，一些设计人员会创建一个<u>带有每个‘唯一订单日期’和‘请求发货日期’组合键的单个日期表</u>。这种方法<strong>在几个方面都行不通</strong>。首先，如果需要处理所有日期组合，那么清洁而简单的每日日期表（每年约365 行）的规模就会膨胀。第二，组合日期表将不再符合其他常用的每日、每周和每月日期维。</p> <h3 id="product-dimension-revisited重新审视产品维度"><a href="#product-dimension-revisited重新审视产品维度" class="header-anchor">#</a> Product Dimension Revisited重新审视产品维度</h3> <p>到目前为止，每个案例研究the case study vignettes都包括了一个产品维度product dimension。产品维度是最常见和最重要的维度表之一。它描述了公司销售的完整产品组合。在许多情况下，产品组合中的产品数量大得惊人，至少从局外人的角度来看是这样。例如，美国一家著名的狗和猫食品制造商跟踪其产品的25,000多个制造变体，包括每个人（或每只狗和猫）都熟悉的零售产品，以及通过商业和兽医渠道销售的许多专业产品。一些耐用品制造商，例如窗户公司，销售数百万种独特的产品配置。大多数产品维度表都具有以下<strong>特征</strong>：</p> <ul><li>许多冗余的、描述性的列。对于制造商来说，维护100 个或更多的产品描述并不罕见。维表属性自然地描述维表行，不会因为另一个维的影响而发生变化，并且随着时间的推移几乎保持不变，尽管一些属性确实会随着时间的推移而缓慢变化。</li> <li>一个或多个属性层次结构attribute hierarchies，加上非层次结构属性non-hierarchical attributes。产品通常会汇总到多个定义的层次结构中。<u>多对一固定深度层次数据The many-to-one fixed depth hierarchical data</u>应该以<u>单个扁平、去重复化的产品维表的形式</u>呈现。你应该<strong>避免</strong>创建规范化的雪花状子表；因为更复杂的呈现方式以及维度内浏览性能变慢所带来的成本，要超过其在存储节省方面微不足道的好处。产品维表可以包含成千上万的条目。由于有这么多行数据，请求获取一个包含产品描述的下拉列表<strong>并不是很有用</strong>。在尝试显示产品描述之前，具备<u>先依据某一个属性（比如口味）进行约束，然后再依据另一个属性（比如包装类型）进行约束的能力</u>是<strong>至关重要</strong>的。任何属性，无论它们是否属于单个层次结构，都应该能被自由地用于浏览以及向上或向下钻取数据。许多产品维度属性都是独立的低基数属性standalone low-cardinality attributes，并非part of explicit hierarchies明确的层次结构的一部分。</li></ul> <p>操作产品主文件operational product master的存在有助于创建和维护产品维，但必须执行一些转换和管理步骤才能将操作主文件转换为维表，包括以下内容：</p> <ul><li>将业务运营产品代码the operational product code重新映射为一个代理键surrogate key。正如我们<font style="color:#DF2A3F;">在第三章中</font>所讨论的，这个无实际意义的代理主键是<strong>必要</strong>的，以避免随着时间推移，由于<u>业务运营产品代码的重复使用</u>而造成的混乱情况。还有可能需要整合来自不同业务运营系统的产品信息。最后，正如你刚刚在<font style="color:#DF2A3F;">第五章 “采购” </font>中所学到的，代理键对于跟踪第二类产品属性的变化type 2 product attribute changes是<strong>必需</strong>的。</li> <li>添加描述性属性值，以扩充或替换操作码operational codes。您<strong>不应该接受</strong><u>业务用户熟悉操作码的借口</u>。业务用户熟悉操作码的唯一原因是他们被迫使用它们！产品维中的列是查询约束和报表标签的唯一来源，因此其内容必须清晰易读。晦涩的缩写和完全的数字代码一样糟糕；它们也应该用易读的文本扩充或替换。单个列中的多个缩写代码应该展开并拆分为不同的属性。</li> <li>对属性值进行质量检查，以确保<strong>不存在</strong>拼写错误、不可能出现的值或多种不同的表述形式。商业智能（BI）应用程序和报表依赖于维度属性的精确内容。如果属性值仅仅因为细微的标点符号或拼写差异而有所不同，SQL 就会在报表中生成另一行数据。你应该<strong>确保</strong>属性值完全填充，因为缺失值很容易导致误解。不完整或管理不善的文本维度属性会导致生成的报表不完整或质量不佳。</li> <li>在元数据中记录属性的定义、解释以及来源。请记住，元数据就如同数据仓库/商业智能（DW/BI）的百科全书。你必须认真谨慎地填充和维护元数据存储库。</li></ul> <p>“operational product master” 可以翻译为 “业务运营产品主数据” 。</p> <p>在这个语境中，它指的是企业在日常业务运营过程中所维护的关于产品的核心、主要数据集合，这些数据包含了产品的基本信息、属性等，是企业开展业务活动（如生产、销售等）所依赖的基础产品数据记录。 它是创建和维护产品维度表的一个基础。</p> <h3 id="customer-dimension客户维度"><a href="#customer-dimension客户维度" class="header-anchor">#</a> Customer Dimension客户维度</h3> <p>客户维度为每个产品发货的独立地点 discrete location to which you
ship a product设置一行记录。根据业务性质的不同，客户维度表的规模可能从适中（数千行）到极其庞大（数百万行）不等。图 6 - 5 展示了一个典型的客户维度表。</p> <p>在客户维度中，通常会同时存在几个相互独立的层次结构。<strong>自然地理层次结构</strong>由送货地址ship-to location清晰定义。由于送货地址是一个空间点，围绕这个点可以定义多个地理层次结构。在美国，常见的地理层次结构是城市、县和州。包含城市 - 州属性通常很有用，因为许多城市名在多个州都存在。邮政编码则标识了二级地理分区。邮政编码的第一位数字标识美国的一个地理区域（例如，0 代表东北部，9 代表某些西部州），而邮政编码的前三位数字标识一个邮件分区中心。</p> <p>尽管这些地理特征可能在单个主数据管理系统中进行捕获和管理，但你<strong>应该</strong>将这些属性嵌入各自的维度中，而不是依赖一个抽象的、通用的地理 / 位置维度（该维度为每个空间点独立设置一行，与其他维度无关）。<font style="color:#DF2A3F;">我们将在第 11 章 “电信”</font> 中进一步讨论这个问题。</p> <p>另一个常见的层次结构是<strong>客户的组织层次结构</strong>（假设客户是一个企业实体）。对于每个客户送货地址，你可能会有一个客户账单地址和客户母公司信息。对于客户维度中的每一行，物理地理位置和组织关联organizational affiliation都有明确的定义，尽管这些层次结构的汇总方式有所不同。</p> <p>NOTE 对于以客户为导向的维度，<u>一个维度同时支持多个独立的层次结构</u>是很自然且常见的。这些层次结构可能具有不同的级别数量。在维度模型中，必须支持在每个层次结构中进行向上和向下钻取操作。</p> <p>细心的读者可能会对其中隐含的假设存在疑问，即多个送货地址multiple ship-tos以多对一的关系汇总到一个账单地址a single bill-to。现实世界可能并非如此简单明了。总会有一些例外情况，即某些送货地址ship-to addresses会与多个账单地址more than one bill-to相关联。显然，这打破了图 6 - 5 中假设的简单层次关系。</p> <ul><li>如果这种情况很少见，可以合理地对客户维度进行概括，使维度的粒度为每个唯一的送货 / 账单地址组合。在这种情况下，如果一个给定的送货地址与两组账单地址信息相关联，那么维度中就会有两行，每行对应一种组合。</li> <li>另一方面，如果许多送货地址与许多账单地址之间存在复杂的多对多关系，那么送货地址和账单地址的客户可能需要作为单独的维度来处理，并通过事实表将它们链接在一起。</li></ul> <p>无论采用哪种方法，所保留的信息都是完全相同的the same information is preserved。我们将在<font style="color:#DF2A3F;">第 7 章 “会计” </font>中进一步讨论组织层次结构organizational hierarchies，包括可变深度递归关系variable depth recursive relationships的处理。</p> <p>“organizational affiliation”，意思是 “组织关联” ，指的是在企业或组织环境中，不同实体（如客户、部门等）之间在组织架构层面上的联系或从属关系。在这句话里，是指客户与所属母公司以及其他相关组织单位之间的关系，这种关系构成了客户维度中的组织层次结构。</p> <h4 id="single-versus-multiple-dimension-tables单维与多维表格"><a href="#single-versus-multiple-dimension-tables单维与多维表格" class="header-anchor">#</a> Single Versus Multiple Dimension Tables单维与多维表格</h4> <p>客户维度中另一个可能的层次结构是‘制造商的销售组织’。设计师有时会<strong>疑惑</strong>，销售组织属性应该建模为一个单独的维度，还是添加到客户维度中。如果销售代表与客户之间存在高度相关的一对一或多对一关系，将销售组织属性与客户属性合并到一个维度中是可行的。最终得到的维度大小不会超过两个维度中较大的那个。在这个单一维度中，可以高效地浏览销售团队与客户之间的关系，而无需遍历事实表。</p> <p>然而，有时销售组织与客户之间的关系更为复杂。需要考虑以下因素：</p> <ul><li>一对一或多对一关系实际上是否是多对多关系？正如前面所讨论的，如果多对多关系是一种特殊情况，你可能仍然倾向于将销售代表属性合并到客户维度中，同时知道需要使用多个代理键来处理这些罕见的多对多情况。但是，如果多对多关系是常态，就应该将销售代表和客户作为单独的维度来处理。</li> <li>销售代表与客户的关系是否会随时间变化，或者受其他维度的影响？如果是这样，你可能需要为销售代表和客户分别创建维度。</li> <li>客户维度是否极其庞大？如果有几百万行客户记录，你更有可能将销售代表视为一个单独的维度，而不是通过庞大的客户维度来进行所有销售代表相关的分析。</li> <li>销售代表维度和客户维度是否独立参与其他事实表？同样，如果是这样，你可能会将这两个维度分开。仅围绕订单数据创建一个包含销售代表属性的单一客户维度，可能会在用户分析涉及销售代表的其他流程时造成混淆。</li> <li>企业是否将销售代表和客户视为不同的事物？这个因素可能难以察觉且无法量化。但是，如果将两个关键维度强行合并为一个混合维度与企业的观点相悖，那就没有意义了。</li></ul> <p>当实体之间存在<u>固定的、不随时间变化且强相关的关系</u>时，它们应该被建模为一个单一维度。在大多数其他情况下，将实体分离为两个维度（同时牢记关于维度数量过多的一般准则）的设计可能会更简单、更易于管理。如果你的模式中已经确定了 25 个维度，那么你应该考虑尽可能合并维度。</p> <p>当维度分开时，一些设计师想要创建一个只包含两个维度键的小表，以显示它们之间的相关性，而不使用订单事实表。在许多情况下，这个二维表是<strong>不必要</strong>的。没有理由为了回应这种关系查询而避开事实表。事实表非常高效，因为它只包含维度键、度量值，偶尔还包含退化维度。<strong>事实表就是专门为表示维度之间的相关性和多对多关系而创建的。</strong></p> <p><font style="color:#DF2A3F;">正如我们在第 5 章中讨论的</font>，可以通过将相关描述作为类型 1 属性包含在客户维度中，来捕获客户当前分配的销售代表。或者，你可以使用缓慢变化维度（SCD）类型 5 的技术，在客户维度中嵌入一个指向销售代表维度分支的类型 1 外键；当前值可以通过视图声明，就好像它们包含在客户维度中一样呈现出来。</p> <h4 id="factless-fact-table-for-customer-rep-assignments客户-代理指派事实表"><a href="#factless-fact-table-for-customer-rep-assignments客户-代理指派事实表" class="header-anchor">#</a> Factless Fact Table for Customer/Rep Assignments客户/代理指派事实表</h4> <p>在结束销售代表与客户分配这个话题之前，用户有时希望能够分析<u>销售代表随时间对客户的复杂分配情况analyze the complex assignment of sales reps to customers over time</u>，即使没有订单活动发生。在这种情况下，可以构建一个无事实事实表factless fact table，如图 6 - 6 所示，以捕获销售代表的覆盖范围。这个覆盖表coverage table 将提供销售代表对客户的历史分配的完整映射，即使其中一些分配assignments从未促成销售。这个无事实事实表包含两个日期键，分别用于表示每次分配的生效日期和过期日期。当前销售代表分配行的过期日期将引用一个特殊的日期维度行，该日期维度行标识一个未来的、未确定的日期。</p> <p>你可能想要将分配事实表与订单事务事实表进行比较，以识别尚未产生订单活动的销售代表分配情况。你可以利用 SQL 的集合操作能力（例如，选择覆盖表中的所有销售代表，并减去订单表中的所有销售代表），或者编写一个相关子查询来实现。</p> <p>“sales reps” 是 “sales representatives” 的缩写，常见释义为 “销售代表” ，指的是受雇于公司，负责向客户推销公司产品或服务的人员。他们的主要职责包括与客户建立联系、了解客户需求、介绍产品或服务的特点和优势，以促成销售交易，并维护客户关系。在商业活动中，销售代表是公司与客户之间的重要纽带。</p> <p>“assignments” 在这里是 “分配；指派” 的意思，结合上下文，指的是销售代表与客户之间的 “分配关系” 或 “指派情况” ，也就是哪些销售代表被分配负责哪些客户。在这个语境中，构建无事实事实表就是为了记录这些销售代表和客户之间的分配关系历史，即便某些分配关系没有促成销售。</p> <h3 id="deal-dimension交易维度"><a href="#deal-dimension交易维度" class="header-anchor">#</a> Deal Dimension交易维度</h3> <p>交易维度与<font style="color:#DF2A3F;">第 3 章中的促销维度</font>类似。交易维度描述了<u>提供给客户的、理论上会影响客户购买产品意愿的激励措施</u>。这个维度有时也被称为合同维度。如图 6 - 7 所示，交易维度描述了<u>与‘特定订单行项目’相关的所有条款、补贴和激励措施的完整组合</u>。</p> <p>在处理这个交易维度时，你会遇到与零售促销维度中相同的问题。如果条款、补贴和激励措施之间存在<u>有用的相关性</u>，将它们整合到一个交易维度中是<strong>有意义的</strong>。如果这些条款、补贴和激励措施之间的相关性很弱，在维度中生成它们的笛卡尔积可能就<strong>不太合适</strong>，此时或许将交易维度拆分为各个独立的组件会更好。这并非是<u>信息增减的问题</u>，因为两种方案下的模式所包含的信息是相同的。最终是选择将这些交易因素表示为多个维度，还是一个维度，<strong>取决于</strong>用户便利性和管理复杂性等因素。在一个非常大的事实表（包含数亿或数十亿行数据）中，如果从<u>减少事实表复合键中的键数量的角度</u>考虑，并且这种做法符合业务用户的观点，那么将交易属性视为一个单一维度是比较合适的。当然，任何行数少于 10 万行的交易维度在这种设计中都是易于处理的。</p> <h3 id="degenerate-dimension-for-order-number-订单编号的退化维度"><a href="#degenerate-dimension-for-order-number-订单编号的退化维度" class="header-anchor">#</a> Degenerate Dimension for Order Number 订单编号的退化维度</h3> <p>订单事实表中的每一行明细each line item row 都将订单编号the order number 作为一个退化维度包含在内。与操作型的表头 / 行或父 / 子数据库an operational header/line or parent/child database[^6.2.6-1]不同，在维度模型中，<strong>订单编号通常不会与订单表头表an order header table[^6.2.6-2]相关联</strong>。你可以将<u>订单表头中所有有价值的详细信息</u>分类到单独的维度中，比如订单日期和客户送货地址维度。（虽然可以将这些信息拆分出去）订单编号<strong>仍然很有用</strong>，原因有以下几点：它能让你对订单上的各个行项目进行分组，进而回答类似 “每个订单的平均行项目数量是多少the average number of line items on an order[^6.2.6-3]?” 这样的问题；订单编号偶尔还用于将数据仓库与操作型系统进行关联；它也可能在事实表的主键中发挥作用。（如何判断一个维度是否是退化维度）<strong>由于订单编号存于事实表中却不与维度表连接，所以它是一个退化维度</strong>。</p> <p>注意：退化维度<strong>通常保留用于</strong>操作事务标识符。它们不应该被用作在事实表中插入晦涩代码而不连接到维度表进行描述性解码的借口。</p> <p>尽管订单事务行编号the order transaction line number可能没有分析用途，但考虑到它在主键中的潜在作用以及与操作型记录系统的关联，它也可能作为第二个退化维度包含在事实表中。在这种情况下，行项目粒度事实表the line item grain fact table的主键将是订单编号和行编号。</p> <p>有时，一些数据元素data elements属于订单本身，但并不自然not naturally地归属于其他维度表。在这种情况下，订单编号<strong>不再是</strong>退化维度，而是一个具有自己的代理键和属性surrogate key and attributes的标准维度a standard dimension。</p> <p>然而，具有深厚操作型背景的设计师应该<strong>避免</strong>将传统的订单表头信息the traditional order header information直接放入订单维度an order dimension的冲动。在<strong>几乎所有情况</strong>下，表头信息更适合放在其他分析维度中，这些维度可以与行项目粒度的事实表相关联，而不是简单地将其归到<u>一个与操作型订单表头记录相似的维度</u>中。</p> <p>[^6.2.6-1]: “operational header/line or parent/child database”指的是操作型数据库中的两种常见结构。“operational header/line database”即操作型表头/行数据库，“header”（表头）存储关于整个事务的通用信息，如订单日期、客户信息等；“line”（行）则存储事务的具体明细内容，像订单中的各个产品项信息。“parent/child database”即父/子数据库，是一种基于层次结构的数据库设计，“parent”（父）表包含概括性信息，“child”（子）表存储更详细的相关信息，通过外键关联，子表依赖父表存在，这种结构用于描述具有层次关系的数据。在维度建模时，需重新组织这类数据库中的数据，如订单编号在操作型数据库里关联表头表，但在维度模型中常作为退化维度，且表头信息会被分到其他合适维度，而不是保留原结构 。</p> <p>[^6.2.6-2]: “order header table”指订单头表，是一种在数据库中用于存储订单相关的总体信息或概要信息的表。在操作型数据库中，订单头表与订单行表（order line table）相对应，共同构成完整的订单数据结构。订单头表通常包含与整个订单相关的通用信息，例如订单编号、订单日期、客户信息、销售代表信息、交易条款等。这些信息适用于整个订单，而非特定的某一个订单行项目。在维度建模中，订单头表的处理方式与传统操作型数据库有所不同。例如，在维度模型里，订单编号通常不再与订单头表紧密相连，而是作为退化维度存在于事实表中，并且会将订单头表中的有趣细节提取出来，分到像订单日期、客户送货地址等单独的维度中，而不是保留一个类似操作型订单头表的维度 。</p> <p>[^6.2.6-3]: “the average number of line items on an order” 常见释义为 “每个订单的平均行项目数量” 。订单中的行项目是指构成订单的具体产品或服务明细，例如一个订单中有多个商品，一个商品的名称、数量、价格可构成一个项目行。在订单相关的数据统计和分析场景中，“每个订单的平均行项目数量”是一个用于衡量订单明细复杂性或规模的指标。</p> <h3 id="junk-dimensions-垃圾维度"><a href="#junk-dimensions-垃圾维度" class="header-anchor">#</a> Junk Dimensions 垃圾维度</h3> <p>在对复杂的事务性源数据进行建模时，你常常会遇到一些杂项指标和标志miscellaneous indicators and flags，它们被填充了一小范围的离散值。对于处理这些低基数low cardinality 的标志和指标，你有几种<strong>不太理想</strong>的选择，包括：</p> <ul><li><strong>忽略标志和指标</strong>：你可以提出是否删除这些杂项标志的常规问题，因为它们看起来似乎不太重要，但这个想法通常会很快被否决，因为偶尔会有人需要用到它们。如果这些指标难以理解或填充不一致，或许就应该将其排除在外。</li> <li><strong>在事实行中保留标志和指标不变</strong>：你既不想在事实表中存储难以辨认的晦涩指标，也不想在事实行中存储冗长的描述，因为这会使表的规模急剧膨胀。在事实行中保留少量文本指标并不是一个好主意。</li> <li><strong>将每个标志和指标都单独作为一个维度</strong>：如果添加到事实表的外键数量仍然合理（大约不超过20个），那么这种做法是可以接受的。然而，如果外键列表已经很长，就应该避免给事实表增加更多混乱。</li> <li><strong>将标志和指标存储在订单表头维度中</strong>：你可以不把订单编号当作退化维度，而是将其作为一个常规维度，并把低基数的标志和指标作为属性。虽然这种方法能准确表示数据关系，但并不建议这么做，原因如下。</li></ul> <p>一种<strong>合适的替代方法</strong>是仔细研究这些标志和指标，然后将它们整合到一个或多个垃圾维度中。垃圾维度类似于你厨房中的杂物抽屉。厨房杂物抽屉是存放各种杂物的地方，比如橡皮筋、回形针、电池和胶带。虽然为橡皮筋单独设置一个抽屉可能更容易找到它们，但你没有足够的存储空间这样做。此外，橡皮筋数量不多，使用频率也不高，不值得专门为其分配一个独立的存储空间。</p> <p>在维度建模领域，垃圾维度这个术语是数据仓库和商业智能专业人员使用的。<strong>与业务用户交流时</strong>，我们通常将垃圾维度称为事务指标维度或事务概况维度。</p> <p><strong>NOTE</strong>：垃圾维度是低基数标志和指标low-cardinality flags and indicators的集合。通过创建垃圾维度，可以将标志the flags从事实表中移除，并将它们置于有用的维度框架a useful dimensional framework中。</p> <p>如果一个垃圾维度包含10个双值指标two-value indicators，如现金支付与信用支付类型，那么最多会有1024（$2^{10}$）行。在这个维度中浏览这些标志可能没什么意义，因为每个标志都可能与其他任何标志同时出现。然而，垃圾维度对于约束或报告这些标志来说是一个<strong>有用的</strong>存储位置。事实表中会有一个指向垃圾维度的单一、较小的代理键。</p> <p>另一方面，如果有一些相关性很低且取值较多的属性，将它们合并到一个垃圾维度中可能并不明智。遗憾的是，这个决策并非完全有公式可循。如果有5个指标，每个指标只有3个可能的值，那么将这些属性合并到一个垃圾维度是最佳选择，因为这个维度只有243（$3^{5}$）个可能的行。然而，如果这5个不相关的指标每个都有100个可能的值，我们建议创建单独的维度，因为这样就会有100,000,000（$100^{5}$）个可能的组合。</p> <p>图6 - 8展示了订单指标维度的示例行。关于垃圾维度有一个微妙的问题，即你应该事先为所有可能的组合创建行，还是在数据中遇到新的组合时再创建垃圾维度行。答案取决于你预期会有多少种可能的组合，以及最大可能的组合数量是多少。一般来说，当理论上的组合数量很多，且你并不期望遇到所有组合时，你可以在提取数据时，每当遇到新的标志或指标组合，就构建一个垃圾维度行。</p> <p>既然已经解释了垃圾维度，现在将其与在订单表头维度中把标志和指标作为属性的处理方式进行对比。如果你想分析订单类型为“入站”（参考图6 - 8中的垃圾维度行）的订单事实，那么事实表将被约束为订单指标键等于1、2、5、6、9、10，可能还有其他一些值。另一方面，如果这些属性存储在订单表头维度中，那么对事实表的约束将是一个包含所有具有入站订单类型的订单编号的庞大列表。</p> <div class="language-mermaid extra-class"><pre class="language-mermaid"><code><span class="token keyword">classDiagram</span>
<span class="token keyword">class</span> OrderIndicatorJunkDimension <span class="token punctuation">{</span>
    OrderIndicatorKey <span class="token text string">(PK)</span>
    PaymentTypeDescription
    PaymentTypeGroup
    OrderType
    CommissionCreditIndicator
<span class="token punctuation">}</span>
</code></pre></div><p>图6 - 8：订单指标垃圾维度的示例行</p> <p>“low cardinality” 意思是 “低基数” 。在数据处理和维度建模的语境中，基数用于描述数据集中不同值的数量。当某个字段或维度的取值范围较小时，即不同值的数量相对较少，就称其具有低基数的特点。比如一些标志和指标，像支付类型（现金、信用卡等少数几种）、订单类型（入站、出站等），它们可能只有几个不同的取值，这就是低基数的体现。在处理这类低基数的标志和指标时，会面临多种处理方式的选择，例如在文中提到可以将它们忽略、留在事实行中、分别作为单独维度，或者组合成垃圾维度等。</p> <p>two-value indicators 指双值指标，即仅有两个可能取值的指标。文中提到的现金支付与信用支付类型（cash versus credit payment type）就是典型的 two-value indicators，它只有 “现金支付” 和 “信用支付” 这两种取值。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blankornotes/ch3.html" class="prev">
        第三章
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blankornotes/assets/js/app.c1ab9062.js" defer></script><script src="/blankornotes/assets/js/2.a76d4e78.js" defer></script><script src="/blankornotes/assets/js/1.2ec8c7d7.js" defer></script><script src="/blankornotes/assets/js/27.58cf19bd.js" defer></script>
  </body>
</html>
