(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{340:function(v,_,t){"use strict";t.r(_);var n=t(25),p=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("本文贡献")]),v._v(" "),_("p",[v._v("前置知识")]),v._v(" "),_("p",[v._v("计算与IO")]),v._v(" "),_("p",[v._v("对于纯计算（只有计算而没有IO）的任务，在单核CPU中，‘有多线程的程序’并不会比‘没有多线程的程序’效率高，甚至因为线程切换导致效率更低。")]),v._v(" "),_("p",[v._v("IO")]),v._v(" "),_("ul",[_("li",[v._v("打印机：发送命令，等待打印机完成")]),v._v(" "),_("li",[v._v("网络/写入磁盘：发送命令，内存写入到磁盘（具体是如何写到磁盘的？可以肯定的是，这个过程应该不需要CPU参与）")])]),v._v(" "),_("p",[v._v("并发与并行")]),v._v(" "),_("p",[v._v("常见的解释是，并行是两个线程‘实际上’在同时工作，并发是两个线程‘看起来’在同时工作。")]),v._v(" "),_("p",[v._v("这个解释是正确的，但它只是对并发和并行概念上的理解，不能解释清楚两者对于‘程序运行的效率’而言有什么不同。")]),v._v(" "),_("p",[v._v("看下图，并发看起来似乎对程序效率的提升没有什么帮助，因为某一时刻只有一个线程在执行，而单线程的程序也是某一时刻只有一个线程在执行")]),v._v(" "),_("p",[v._v("多核处理器")]),v._v(" "),_("p",[v._v("并行与并发之间的区别，关键在于能不能提速（speedup）。")]),v._v(" "),_("p",[v._v("Python在不同场景下如何实现‘并发’（各种风格的并发程序）：")]),v._v(" "),_("ul",[_("li",[v._v("在并发量较小的场合可以使用线程（thread），")]),v._v(" "),_("li",[v._v("如果要运行大量的并发函数，那么可以使用协程（coroutine）。")]),v._v(" "),_("li",[v._v("并行任务，可以通过系统调用、子进程与C语言扩展（C extension）来实现，但要写出"),_("u",[v._v("真正能够并行的Python代码")]),v._v("，其实是很困难的。")])]),v._v(" "),_("p",[v._v("Python有相当成熟的函数库可以运行并管理‘子进程’（这里的子程序指的是什么？），这让我们能够通过Python语言把其他一些工具（例如命令行工具）很好地‘拼接’起来。Shell脚本经常容易越写越复杂，所以我们有时干脆就考虑改用Python来实现，这样更容易理解，也更容易维护。")]),v._v(" "),_("p",[v._v("由Python所启动的子进程可以平行地运行，这让我们能够充分利用计算机的每一个CPU核心，来尽量提升程序的处理效率。虽然Python解释器本身有可能会局限在一个CPU上面（参见第53条），但我们还是很容易就能通过Python来‘驱动’并‘协调’CPU密集型（CPU-intensive）的任务。")]),v._v(" "),_("p",[v._v("附录：字典")]),v._v(" "),_("p",[v._v("（这个附录是用来总结并补充‘实现某种需求的所有实现方式’）")])])}),[],!1,null,null,null);_.default=p.exports}}]);