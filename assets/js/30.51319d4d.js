(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{341:function(a,t,s){"use strict";s.r(t);var n=s(25),e=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("设计模式是由那些有丰富工程经验的人来写的，在学习设计模式时一定要有‘错误的例子’，这些错误的例子可以被当作‘经验’，而不能只看‘正确的例子’，正确的例子更像是一个‘模板’，是看不出来经验的。")]),a._v(" "),t("ul",[t("li",[a._v("一种是从错误的（有缺陷）实现逐渐演变为正确的（完善）实现，学习方法是从错误例子逐步看如何完善为正确例子即可")]),a._v(" "),t("li",[a._v("一种是经典到有标准答案的实现，这类的学习方法是，先看标准答案，观察尝试修改标准答案后会出现哪些问题")])]),a._v(" "),t("h1",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[a._v("#")]),a._v(" 单例模式")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TaskManager")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TaskManager")]),a._v(" instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n                            "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// private + static")]),a._v("\n                            "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 为了让外界可以访问这个唯一实例，需要在TaskManager中定义一个静态的TaskManager类型的私有成员变量")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TaskManager")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                            "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// private + 构造器")]),a._v("\n                            "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 禁止直接使用new来创建对象")]),a._v("\n                            "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 更准确的说，禁止类的外部直接使用new来创建对象")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/*\n    public static TaskManager getInstance() {\n        return instance;\n    }\n    */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TaskManager")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TaskManager")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" instance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("为什么要将成员变量tm定义为静态变量？")]),a._v(" "),t("p",[a._v("如果不声明为静态变量，获取实例的方法getInstance就必须为非静态方法（静态方法尝试访问非静态变量，‘编译器’就会报错），要调用非静态方法，必须通过实例化对象调用。这就导致‘要获取唯一对象，需要先创建一个对象’，这完全违背了单例模式。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("EagerSingleton")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("EagerSingleton")]),a._v(" instance "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("EagerSingleton")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("EagerSingleton")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("EagerSingleton")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInstance")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" instance"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h1",{attrs:{id:"简单工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式"}},[a._v("#")]),a._v(" 简单工厂模式")]),a._v(" "),t("p",[a._v("集中式工厂的实现—简单工厂模式")]),a._v(" "),t("h2",{attrs:{id:"需求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需求"}},[a._v("#")]),a._v(" 需求")]),a._v(" "),t("ul",[t("li",[a._v("基本功能：Sunny软件公司欲基于Java语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。")]),a._v(" "),t("li",[a._v("可扩展性：Sunny软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。")])]),a._v(" "),t("h2",{attrs:{id:"方案一"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案一"}},[a._v("#")]),a._v(" 方案一")]),a._v(" "),t("p",[a._v("（1）代码冗长")]),a._v(" "),t("ul",[t("li",[a._v("在Chart类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；")]),a._v(" "),t("li",[a._v("而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。")])]),a._v(" "),t("p",[a._v("（2）职责过重")]),a._v(" "),t("ul",[t("li",[a._v("Chart类的职责过重，它负责‘初始化’和‘显示’所有的图表对象，将各种图表对象的‘初始化代码’和‘显示代码’集中在一个类中实现，违反了单一职责原则，不利于类的重用和维护；")]),a._v(" "),t("li",[a._v("而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。")])]),a._v(" "),t("p",[a._v("（3）当需要增加新类型的图表时，必须修改Chart类的源代码，违反了开闭原则。")]),a._v(" "),t("p",[a._v("（4）客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离。")]),a._v(" "),t("p",[a._v("（5）客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等。如果在Chart类的构造函数中没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建Chart对象时都会出现，导致代码的重复。")]),a._v(" "),t("h2",{attrs:{id:"方案二"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案二"}},[a._v("#")]),a._v(" 方案二")]),a._v(" "),t("ol",[t("li",[a._v("首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类。")]),a._v(" "),t("li",[a._v("然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象。客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。")])]),a._v(" "),t("p",[a._v("定义如下：简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，它属于类创建型模式。")]),a._v(" "),t("h2",{attrs:{id:"方案三"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案三"}},[a._v("#")]),a._v(" 方案三")]),a._v(" "),t("p",[a._v("问题：在创建具体Chart对象时，每更换一个Chart对象都需要修改客户端代码中静态工厂方法的参数（即"),t("code",[a._v('chart = ChartFactory.getChart("histogram")')]),a._v("中的histogram），客户端代码将要重新编译，这对于客户端而言，违反了开闭原则。")]),a._v(" "),t("p",[a._v("缺点：")]),a._v(" "),t("ul",[t("li",[a._v("（1）由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。")]),a._v(" "),t("li",[a._v("（2）使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。")]),a._v(" "),t("li",[a._v("（3）系统扩展困难。一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。")]),a._v(" "),t("li",[a._v("（4）简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。")])]),a._v(" "),t("h1",{attrs:{id:"工厂方法模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式"}},[a._v("#")]),a._v(" 工厂方法模式")]),a._v(" "),t("p",[a._v("多态工厂的实现—工厂方法模式")]),a._v(" "),t("ul",[t("li",[a._v("简单工厂模式虽然简单，但存在一个很严重的问题：当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背开闭原则。")]),a._v(" "),t("li",[a._v("如何实现增加新产品而不影响已有代码？工厂方法模式为此应运而生。")])]),a._v(" "),t("h2",{attrs:{id:"需求-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需求-2"}},[a._v("#")]),a._v(" 需求")]),a._v(" "),t("p",[a._v("Sunny软件公司欲开发一个系统运行日志记录器（Logger），")]),a._v(" "),t("ul",[t("li",[a._v("该记录器可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。")]),a._v(" "),t("li",[a._v("在设计各类日志记录器时，Sunny公司的开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。")])]),a._v(" "),t("p",[a._v("如何封装记录器的初始化过程并保证多种记录器切换的灵活性是Sunny公司开发人员面临的一个难题。")]),a._v(" "),t("p",[a._v("需求分析：")]),a._v(" "),t("p",[a._v("（1）需要封装日志记录器的初始化过程，这些初始化工作较为复杂。例如需要初始化其他相关的类，还有可能需要配置工作环境（例如连接数据库或创建文件），导致代码较长。如果将它们都写在构造函数中，会导致构造函数庞大，不利于代码的修改和维护。")]),a._v(" "),t("p",[a._v("（2）用户可能需要更换日志记录方式，在客户端代码中需要提供一种灵活的方式来选择日志记录器，尽量在不修改源代码的基础上更换或者增加日志记录方式。")]),a._v(" "),t("h2",{attrs:{id:"方案一-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方案一-2"}},[a._v("#")]),a._v(" 方案一")]),a._v(" "),t("p",[a._v("按照简单工厂模式")]),a._v(" "),t("p",[a._v("实现了对象的创建和使用分离")]),a._v(" "),t("p",[a._v("（1）工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大。（2）系统扩展不灵活，如果增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反了开闭原则。")]),a._v(" "),t("p",[a._v("在简单工厂模式中")]),a._v(" "),t("ul",[t("li",[a._v("只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每个产品对象的创建细节，并决定何时实例化哪一个产品类。")]),a._v(" "),t("li",[a._v("简单工厂模式最大的缺点是当有新产品要加入系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了开闭原则。")]),a._v(" "),t("li",[a._v("此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。")])]),a._v(" "),t("p",[a._v("在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。工厂方法模式定义如下：")]),a._v(" "),t("p",[a._v("工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式（Factory Pattern），又可称作虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern）。工厂方法模式是一种类创建型模式。")]),a._v(" "),t("p",[a._v("方案二")]),a._v(" "),t("ul",[t("li",[a._v("为各种日志记录器提供默认实现；")]),a._v(" "),t("li",[a._v("还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；")]),a._v(" "),t("li",[a._v("也可以将参数封装在一个Object类型的对象中，通过Object对象将配置参数传入工厂类。")]),a._v(" "),t("li",[a._v("当然，对于同一个具体工厂而言，无论使用哪个工厂方法，创建的产品类型均要相同。")])]),a._v(" "),t("p",[a._v("简化客户端的使用")]),a._v(" "),t("p",[a._v("对客户端隐藏‘工厂方法’。此时，在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。")]),a._v(" "),t("h1",{attrs:{id:"抽象工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式"}},[a._v("#")]),a._v(" 抽象工厂模式")]),a._v(" "),t("p",[a._v("产品族的创建—抽象工厂模式")]),a._v(" "),t("p",[a._v("Sunny软件公司欲开发一套界面皮肤库，可以对Java桌面软件进行界面美化。为了保护版权，该皮肤库源代码不打算公开，而只向用户提供已打包为jar文件的class字节码文件。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素")]),a._v(" "),t("p",[a._v("（1）当需要增加新的皮肤时，虽然不需要修改现有代码，但是"),t("u",[a._v("需要增加大量类")]),a._v("。针对每一个新增具体组件都需要增加一个具体工厂，类的个数成对增加，这无疑会导致系统越来越庞大，从而增加了系统的维护成本和运行开销。")]),a._v(" "),t("p",[a._v("（2）由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置。如果某个具体工厂选择失误将会导致界面显示混乱，虽然可以适当增加一些约束语句，但客户端代码和配置文件都较为复杂。")]),a._v(" "),t("p",[a._v("当系统所提供的工厂生产的具体产品并不是一个‘简单的对象’，而是‘多个位于不同产品等级结构、属于不同类型的具体产品’时，就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。")]),a._v(" "),t("p",[a._v("抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是‘一个产品等级结构’，而抽象工厂模式需要面对‘多个产品等级结构’，一个工厂等级结构可以负责‘多个不同产品等级结构中的产品对象的创建’。当一个工厂等级结构可以创建出‘分属于不同产品等级结构的一个产品族中的所有对象’时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如图6-4所示。")])])}),[],!1,null,null,null);t.default=e.exports}}]);