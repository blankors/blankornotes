# 1 Data Warehousing, Business Intelligence, and Dimensional Modeling Primer入门

本章为后续章节奠定基础。我们首先从宏观角度审视数据仓库和商业智能（DW/BI）系统。你可能会失望地发现，我们并没有从技术和工具入手——最重要的是，DW/BI系统必须以满足业务需求为**首要考量**。在明确业务需求后，我们再反向推进逻辑设计、物理设计，并做出关于技术和工具的决策。

在本章中，我们明确了数据仓库和商业智能的目标，同时留意到DW/BI经理的职责与出版商的职责之间存在惊人的相似之处。

基于这一全局视角，我们探索了维度建模的核心概念，建立了基本术语。随后，本章讨论了Kimball DW/BI架构的主要组成部分，并对不同的架构方法进行了比较；幸运的是，无论你倾向于哪种架构，维度建模都能发挥作用。最后，我们回顾了常见的关于维度建模的误解。在本章结束时，你将认识到在处理DW/BI项目时，需要兼具数据库管理员（DBA）和商业分析师（MBA）的能力。

第1章讨论了以下概念：

- 数据仓库和商业智能的业务驱动目标
- DW/BI系统的出版隐喻
- 维度建模的核心概念和术语，包括事实表和维度表
- Kimball DW/BI架构的组件和原则
- 不同DW/BI架构的比较，以及维度建模在每种架构中的作用
- 对维度建模的误解 

## Different Worlds of Data Capture and Data Analysis

任何组织最重要的资产之一便是其信息information。这些信息几乎总是用于两个目的：运营记录保存和分析决策。简单来说，运营系统是用来输入数据的地方，而数据仓库/商业智能（DW/BI）系统则是提取数据的地方。 

<u>运营系统的用户</u>推动着组织的运转。他们处理订单、招揽新客户、监控运营活动的状态并记录投诉。运营系统经过优化，能够快速处理事务。这些系统通常一次处理一条交易记录，可预测地反复执行相同的运营任务，执行组织的业务流程。鉴于这种执行重点，运营系统**通常不会**保留历史数据，而是更新数据以反映最新状态。 

另一方面，<u>DW/BI系统的用户</u>观察组织的运转情况以评估绩效。他们统计新订单数量，并与上周的订单进行比较，询问新客户签约的原因以及客户投诉的内容。他们担心运营流程是否正常运作。尽管他们需要详细的数据来支持其不断变化的问题，但DW/BI系统的用户几乎从不一次处理一笔交易。这些系统针对高性能查询进行了优化，因为用户的问题通常需要搜索成百上千甚至数十万笔交易，并将其压缩成一个答案集。更复杂的是，DW/BI系统的用户通常要求保留历史背景信息，以便准确评估组织随时间推移的绩效。 

在《数据仓库工具箱》（Wiley，1996年）第一版中，拉尔夫·金博尔（Ralph Kimball）用了一整章来描述<u>运营处理和数据仓库这两个领域之间的差异</u>。如今，人们普遍认识到，DW/BI系统与记录用的运营系统在需求、用户、结构和节奏上有着巨大的差异。不幸的是，我们仍然会遇到一些所谓的DW/BI系统，它们<u>只不过是存储在单独硬件平台上的运营记录系统的副本</u>。尽管这些环境可能因性能原因满足了隔离运营和分析环境的需求，但它们并没有解决这两种系统之间的其他固有差异。业务用户对这些伪数据仓库提供的可用性和性能并不满意；这些冒牌货对DW/BI系统有害，因为它们没有认识到其用户与运营系统用户的需求截然不同。 

## Goals of Data Warehousing and Business Intelligence

## Dimensional Modeling Introduction 维度建模简介

既然你已经了解了DW/BI系统的目标，现在让我们来探讨维度建模的基础知识。维度建模被广泛认为是呈现分析数据的首选技术，因为它同时满足两个要求：

- 提供业务用户能够理解的数据。
- 实现快速的查询性能。

维度建模**是**一种长期以来<u>用于简化数据库的技术</u>。在过去的五十多年里，在众多案例中，IT组织、顾问和业务用户自然地倾向于采用简单的维度结构，以满足人类对简单性的基本需求。简单性至关重要，因为它确保用户能够轻松理解数据，同时也能让软件快速有效地导航并提供结果。

想象一位高管这样描述她的业务：“我们在不同市场销售产品，并随时间衡量我们的业绩。” 维度设计师会仔细留意其中对产品、市场和时间的强调。大多数人会直观地将这样的业务想象成一个数据立方体，其边缘分别标记为产品、市场和时间。想象一下沿着这些维度进行切片和切块操作。立方体内部的各个点存储着针对特定产品、市场和时间组合的度量值，比如销售量或利润。能够以具体、有形的方式将像数据集这样抽象的事物可视化，这就是**易懂性的秘诀**。如果这种视角看起来过于简单，那就对了！一个在设计之初就很简单的数据模型，在设计结束时仍有可能保持简单。而一个一开始就很复杂的模型，到最后肯定会过于复杂，导致查询性能低下，还会遭到业务用户的拒绝。阿尔伯特·爱因斯坦（Albert Einstein）曾说过：“把一切都变得尽可能简单，但不要过于简单。” 这句话体现了驱动维度设计的基本理念。

虽然维度模型通常在关系数据库管理系统中实例化，但它们与第三范式（3NF）模型有很大不同，第三范式模型旨在消除数据冗余。规范化的3NF结构将数据划分为许多离散的实体，每个实体都成为一个关系表。一个销售订单数据库可能从每个订单行的一条记录开始，但在3NF模型中会变成一个复杂的蜘蛛网图，可能由数百个规范化表组成。

业界有时将3NF模型称为实体 - 关系（ER）模型。实体 - 关系图（ER diagrams或ERDs）是用于表示表之间关系的图表。3NF模型和维度模型都可以用ERD表示，因为它们都由连接的关系表组成；3NF模型和维度模型的关键区别在于规范化程度。由于这两种模型类型都可以用ERD呈现，我们避免将3NF模型称为ER模型；相反，我们称它们为**规范化模型**（首次出现），以尽量减少混淆。

规范化的3NF结构在操作处理中非常有用，因为更新或插入事务只会在数据库的一个地方进行操作。然而，规范化模型对于BI查询来说过于复杂。用户无法理解、导航或记住那些像洛杉矶高速公路系统地图一样复杂的规范化模型。同样，大多数关系数据库管理系统也无法高效地查询规范化模型；用户不可预测的查询的复杂性会使数据库优化器不堪重负，导致查询性能灾难性下降。在DW/BI展示层使用规范化模型会妨碍直观且高性能的数据检索。幸运的是，维度建模解决了展示层中模式过于复杂的问题。

注意：维度模型包含与规范化模型相同的信息，但它将数据以一种能够提供用户易懂性、查询性能和对变化的适应性的格式进行封装。 

### Star Schemas Versus OLAP Cubes

在关系数据库管理系统中实现的维度模型被称为星型模式，因为它们类似于星状结构。在多维数据库环境multidimensional database environments中实现的维度模型则被称为联机分析处理（OLAP）多维数据集online analytical processing (OLAP) cubes，如图1-1所示。

如果你的数据仓库/商业智能（DW/BI）环境中包含星型模式或OLAP多维数据集，那么它就利用了维度概念。星型模式和多维数据集都有一个具有可识别维度的通用逻辑设计；然而，它们的物理实现方式有所不同。 

当数据加载到OLAP多维数据集中时，它会使用为维度数据设计的格式和技术进行存储和索引。性能聚合或预先计算的汇总表通常由OLAP多维数据集引擎创建和管理。因此，由于预先计算、索引策略和其他优化，多维数据集提供了卓越的查询性能。业务用户可以通过在分析中添加或删除**属性**（首次出现）来进行深入或深入分析，而无需发出新的查询[^1.3-]。OLAP多维数据集还提供了比SQL更强大的分析功能。**缺点是**，你为这些功能付出了负载性能的代价pay a load performance price，尤其是在大型数据集的情况下。

![image-20250329154004110](./assets/image-20250329154004110.png)

幸运的是，本书中的大多数建议都适用于关系数据库平台和多维数据库平台。尽管OLAP技术的能力在不断提高，但我们通常**建议**将详细的原子信息加载到星型模式中；然后从星型模式填充可选的OLAP多维数据集。因此，本书中的大多数维度建模技术都是用关系星型模式来表达的。



“attribute” 指的是维度表中的属性。业务用户在分析时可以通过添加或移除这些属性来进行下钻或上卷操作，且能在不发出新查询的情况下获得出色的性能表现。维度表通常包含许多低基数的文本属性，这些属性是业务用户进行分析操作的重要对象，也是查询和商业智能（BI）应用程序中约束和分组规范的主要目标，报表上的描述性标签通常也是维度属性的域值。



multidimensional database environments 指多维数据库环境，是与关系数据库管理系统不同的一种数据库环境。

| 比较维度           | 多维数据库环境                                               | 关系数据库管理系统环境                                       |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据模型构建       | 采用多维模型，以OLAP多维数据集为核心，围绕业务维度和事实构建，维度间通过预定义层次结构和关系关联，便于多角度快速分析数据 | 依据关系模型构建，强调数据规范化，通过主键和外键关联不同表，减少数据冗余，确保数据一致性和完整性 |
| 数据存储与索引方式 | 采用面向分析的存储格式，常为列式存储，建立位图索引等特殊索引结构，进行预计算和聚合 | 多以行式存储为主，主要使用B树索引等传统索引类型，一般不进行大规模预计算 |
| 查询与分析功能侧重 | 专为复杂分析查询设计，支持钻取、切片、切块和旋转等强大分析操作，具备丰富分析函数和算法 | 侧重于处理事务性查询，支持基本增删改查操作，确保数据一致性和事务ACID特性，复杂分析操作实现相对复杂 |
| 数据更新与维护操作 | 数据更新相对不频繁，更新可能涉及预计算数据和索引的同步更新，加载和更新需特定工具或接口 | 数据更新操作灵活，支持实时增删改，通过事务机制确保数据一致性，利用成熟备份恢复机制保障数据安全，恢复操作相对简单直接 |



| 比较维度             | Star Schemas（星型模式）                                     | OLAP Cubes（联机分析处理多维数据集）                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据存储与组织结构   | 在关系数据库管理系统中实现，<u>以事实表为核心，周围环绕多个维度表</u>。事实表存度量数据，维度表提供描述性上下文信息，各表通过主键和外键关联，形似星星，结构简单直观。如零售业务中销售事实表结合日期、产品、店铺等维度表描述销售事件 | 在多维数据库环境中构建，<u>将数据组织成多维结构，类似多维立方体</u>。每个维度代表分析视角，事实数据存储在立方体交叉点上，能直接支持复杂数据分析操作 |
| 查询性能与优化方式   | 查询性能依赖数据库查询优化器和索引机制，合理设计索引可助优化器快速定位检索数据。处理复杂查询（尤其多维度聚合分析）时，需编写复杂 SQL 语句，性能可能受影响 | 针对分析操作优化，利用预计算和索引策略提升性能。提前计算存储常用汇总数据，查询时直接使用，减少实时计算量。用户进行钻取、切片、切块等操作能快速获结果，处理复杂分析查询性能更优 |
| 数据加载与维护复杂度 | 数据加载简单直接，从源系统抽取数据，经清洗、转换后加载到事实表和维度表。数据更新时直接对表操作，维护成本相对较低 | 数据加载需复杂预处理，包括数据聚合和索引构建。数据变化（尤其涉及缓慢变化维度）时，可能需重新处理部分或全部数据，维护复杂度较高 |
| 适用场景与灵活性     | 适用于数据量大、查询需求灵活多样的场景。基于关系数据库，能结合传统数据库功能，支持各类查询，但面对复杂多维分析和即席查询时，灵活性不如 OLAP Cubes | 适合大量复杂数据分析和决策支持场景。用户可从多维度深入分析数据，支持即席查询和动态报表生成，但处理大规模事务性数据时，性能和灵活性不如星型模式 |



以向下钻取操作为例：1、选择维度和属性，在 OLAP 工具的界面上，用户先确定要分析的数据维度，比如在销售数据中选择 “时间” 维度。假设初始界面展示的是按季度统计的销售额，此时数据是聚合后的状态。2、添加属性展开数据，若用户想了解每个季度内各月份的销售情况，只需在操作界面中选择添加 “月份” 属性。OLAP 多维数据集会根据已有的预计算数据和索引，快速将数据按照月份展开，展示出每个月的销售额等相关数据，实现从季度维度到月份维度的向下钻取。同理，如果在产品维度上，初始展示的是产品大类的销售数据，用户添加产品子类属性，就能看到每个子类产品的销售明细。



Hive、ClickHouse如何实现OLAP Cubes将数据组织成多维结构？不能原生实现

哪些工具能原生实现？Apache Kylin、Microsoft Analysis ServicesOracle Essbase

为什么说Kylin具有‘原生’的Cube概念，而ClickHouse没有原生的Cube概念？

Kylin以 Cube 为中心进行数据处理，在数据加载阶段，Kylin 会根据用户定义的 Cube 模型，对源数据进行全面的预计算，生成所有可能的维度组合（Cuboid）数据，并存储在 HBase 中。ClickHouse采用实时查询计算的方式处理数据。它不依赖预计算所有维度组合的数据，而是在查询时根据具体的查询条件，实时对存储的数据进行扫描、计算和聚合。



### OLAP Deployment Considerations OLAP部署注意事项

如果要将数据部署到OLAP多维数据集deploy data into OLAP cubes，以下这些事项需要牢记：

- 关系数据库中的星型模式是构建OLAP多维数据集的良好物理基础，并且通常被认为是更稳定的备份和恢复基础。
- 传统上，OLAP多维数据集相较于关系数据库管理系统（RDBMS）有着显著的性能优势，但随着计算机硬件（如设备和内存数据库）以及RDBMS软件（如列式数据库）的发展，这种差异已变得不那么明显。
- OLAP多维数据集的数据结构在不同厂商之间的差异比关系数据库管理系统更大，因此最终的部署细节往往取决于所选的OLAP厂商。通常，在不同的OLAP工具之间移植BI应用程序要比在不同的关系数据库之间移植更困难。
- OLAP多维数据集通常比RDBMS提供更复杂的安全选项，例如限制对详细数据的访问，但对汇总数据提供更开放的访问权限。
- OLAP多维数据集提供的分析功能比受SQL限制的RDBMS丰富得多。这可能是使用OLAP产品的主要理由。
- OLAP多维数据集能够很好地支持缓慢变化维度的类型2变化（将在第5章 “采购” 中讨论），但每当使用其他缓慢变化维度技术覆盖数据时，多维数据集通常需要部分或全部重新处理。
- OLAP多维数据集能够很好地支持事务型和周期快照型事实表，但由于上述覆盖数据的限制，无法处理累积快照型事实表。
- OLAP多维数据集通常使用原生查询语法支持深度不确定的复杂层次结构，如组织结构图或物料清单，这种语法比RDBMS所需的方法更优越。
- 与关系数据库相比，OLAP多维数据集可能对实现向下钻取层次结构的维度键结构施加更详细的约束。
- 一些OLAP产品不支持维度角色或别名，因此需要定义单独的物理维度。

我们将回到关系平台上的维度建模，继续探讨星型模式的两个关键组件。 



### Fact Tables for Measurements 用于度量的事实表

维度模型中的事实表存储着企业业务流程事件产生的性能度量数据。你应努力将<u>业务流程产生的底层度量数据</u>存储在单个维度模型中。由于度量数据在数据量上占比极大，不应为了企业内不同组织职能的需求，而在多个地方重复存储。让来自不同组织的业务用户访问每个度量数据集的单一集中存储库，可确保企业内数据使用的一致性。

“事实” 代表一项业务度量。想象一下，站在市场中观察产品销售情况，为每笔销售交易中的每个产品记录单位数量和美元销售额。这些度量数据在产品在收银台被扫描时进行捕获，如图1-2所示。

![image-20250329165745136](./assets/image-20250329165745136.png)

事实表中的每一行都对应一个度量事件measurement event。每行数据都处于特定的详细级别a specific level of detail，称为**粒度**，例如每销售一个产品在销售交易中对应一行数据。维度建模的**核心原则**之一是，事实表中的所有度量行必须具有相同的粒度。严格遵循这一原则创建具有单一详细级别a single level of detail的事实表，可确保度量数据不会被重复计算。

注意：<u>物理世界中的度量事件</u>与<u>相应事实表中的单个行</u>存在一一对应关系，这是维度建模的**基本原则**。其他所有内容都建立在这个基础之上。

**最有用**的事实是数值型且可累加的，例如美元销售额。在本书的案例研究中，我们将使用美元作为标准货币，以使示例更具体——如果你的本地货币不是美元，可自行替换。

可累加性至关重要，因为BI应用程序很少只检索事实表中的单个行。相反，它们一次会返回数百、数千甚至数百万行事实数据，而处理这么多行数据最有用的操作就是将它们相加。无论用户如何对图1-2中的数据进行切片分析，销售数量和销售额都能相加成一个有效的总计。你会发现，事实有时是半可累加的，甚至是不可累加的。半可累加事实，如账户余额，不能在时间维度上进行求和。不可累加事实，如单价，则根本不能进行累加。在这种情况下，你只能使用计数和平均值，或者逐行打印事实数据 —— 但对于拥有十亿行数据的事实表来说，这并不实际。

事实通常被描述为连续取值，这有助于区分事实和维度属性dimension attribute。在这个例子中，美元销售额是连续取值的，因为它可以在很广的范围内取几乎任何值。作为观察者，你必须在市场中等待度量发生，才能知道其具体值you must stand out in the marketplace and wait for the measurement before
you have any idea what the value will be。

从理论上讲，度量事实可能是文本型的，但这种情况**很少出现**。在大多数情况下，文本型度量是对某事物的描述，且来自离散的值列表。设计人员**应尽量**将文本数据放入维度表中，这样可以更有效地与其他文本维度属性进行关联，并且占用的空间更少。**不应**在事实表中存储冗余的文本信息，**除非**文本对于事实表中的每一行都是唯一的，否则它应属于维度表。真正的文本事实很少见，因为文本事实的内容不可预测，例如自由格式的文本评论，这使得对其进行分析几乎不可能。

参考图1-2中的示例事实表，如果某一产品没有销售活动no sales activity，就**不要**在表中插入任何行。重要的是，不要试图用表示无活动的零来填充事实表，因为这些零会使大多数事实表变得庞大。通过仅包含实际活动数据，事实表往往比较稀疏。尽管事实表很稀疏，但它们通常占维度模型总存储空间的90% 或更多。事实表在行数方面往往很深，但在列数方面较窄（行数多列数少）。考虑到其大小，你应该谨慎利用事实表的空间。

在本书后续的示例中，你会看到所有事实表的粒度**都属于以下三类之一**：事务型、周期快照型和累积快照型。事务型粒度的事实表最为常见。我们将在第3章 “零售销售” 中介绍事务型事实表，并在第4章 “库存” 中介绍周期型和累积型快照事实表。

所有事实表都有两个或更多的外键（参考图1-2中的外键表示法），这些外键与维度表的主键相关联。例如，事实表中的产品键始终与产品维度表中的某个特定产品键相匹配。当事实表中的所有键都能正确地与其对应维度表中的各自主键相匹配时，这些表就满足了参照完整性。你可以通过与事实表相连的维度表来访问事实表。 
事实表通常有其自身的主键，该主键由外键的一个子集组成。这个键通常被称为复合键。**每一个拥有复合键的表都是事实表。**事实表表达的是多对多的关系。**其他所有的表都是维度表。**

通常会有几个维度共同唯一地标识事实表中的每一行。在确定了<u>整个维度列表中的这个子集之</u>后，其余的维度<u>在事实表行的主键所限定的情境下</u>都只取单一值。换句话说，它们是附带存在的。 



“a business measure”（一项业务度量）指的是在业务流程中产生的用于衡量业务表现的具体数据。例如，在观察市场中产品销售情况时，每笔销售交易中每个产品的单位数量（unit quantity）和以美元计算的销售额（dollar sales amount）就是业务度量，这些度量数据在产品于收银台被扫描时进行捕获。 

“dimension”（维度）是一个更宽泛的概念，它代表了观察业务数据的角度，比如时间、产品、地区等维度。而 “dimension attribute”（维度属性）是维度的具体描述性信息，是维度的组成部分。例如在产品维度中，产品名称、产品类别、品牌等属于产品维度的属性，即 “dimension attribute”。也就是说，“dimension” 包含了多个 “dimension attribute”，“dimension attribute” 是对 “dimension” 从不同方面进行的详细描述 ，用于更细致地刻画和区分维度下的具体情况。

这里所提到的 “稀疏” 并非传统意义上事实表单元格中存在大量空白或缺失值（比如某个单元格本该有数据但没填）。文中所指的 “稀疏” 是因为按照 “如果某一给定产品没有销售活动，就不在表中插入任何行” 的原则，在实际业务中，大量产品在某些时段没有销售活动（即没有实际活动数据），所以事实表不会为这些产品插入行。从整体上看，事实表中就会有很多对应无活动产品的位置没有行记录，这种大量因无活动产品而没有行记录的情况，使得事实表从行的角度呈现出 “稀疏” 的状态，即存在很多空缺的行位置。 

在事实表中，通常有几个特定的维度组合在一起能够‘唯一’地确定每一行数据。比如说，可能产品维度、时间维度和地点维度等结合起来，就能准确地标识出唯一一笔具体的销售记录是关于哪个产品、在什么时间、在什么地点发生的。当确定了这几个关键的维度子集后，事实表中其余的维度在该行主键所设定的范围内就只会有一个固定的值。


### Dimension Tables for Descriptive Context



### Facts and Dimensions Joined in a Star Schema




## Kimball's DW/BI Architecture

## Alternative DW/BI Architectures

## Dimensional Modeling Myths



## More Reasons to Think Dimensionally

## Agile Considerations

## Summary